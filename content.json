{"meta":{"title":"zgshen's note","subtitle":null,"description":null,"author":"zguishen","url":"https://zguishen.com"},"pages":[{"title":"关于","date":"2021-03-16T07:44:09.018Z","updated":"2021-03-16T07:44:09.018Z","comments":false,"path":"about/index.html","permalink":"https://zguishen.com/about/index.html","excerpt":"","text":"Java后端开发者2016年毕业于广大随便写写，记录生活，分享技术联系我 zguishen@foxmail.com"}],"posts":[{"title":"【轉載】打造「極度專注力」，其實很簡單","slug":"59【轉載】打造「極度專注力」，其實很簡單","date":"2021-03-15T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/e43fadb9.html","link":"","permalink":"https://zguishen.com/posts/e43fadb9.html","excerpt":"","text":"被打亂思緒要再重組的確很難，到現在我也仍未掌握「不被打斷」或是「即使被打斷還能輕鬆地整理好思緒、繼續做事」的能力。 注意力被分散的原因可能來自外部或內部，《極度專注力》這本書中則討論到如何開啟「極度專注力模式」。 作者克里斯・貝利（Chris Bailey）提到，想進入這個模式，有 4 個步驟。不知道是為什麼，有時候在書寫時能夠專心致志完全不受外界干擾，一口氣將文章寫完，而有時候卻會不斷地被雜音或是內心所擾亂。 你一定也有過這樣的經驗，就是當你終於順利進入了專注狀態，正要好好地完成手邊的工作時，剛好旁邊的人發出聲響或突然跟你說話，打斷了你好不容易開始連貫的思緒，讓組裝好的想法又亂成一團，必須費很大一番功夫才能重新整理好，更多時候還無法將思緒歸回原位。 被打亂思緒要再重組的確很難，到現在我也仍未掌握「不被打斷」或是「即使被打斷還能輕鬆地整理好思緒、繼續做事」的能力。 注意力被分散的原因可能來自外部或內部，《極度專注力》這本書中則討論到如何開啟「極度專注力模式」。 作者克里斯・貝利（Chris Bailey）提到，想進入這個模式，有 4 個步驟。 一、選定一項你打算專注其中的任務 有了目標我們才能知道如何安排注意力，有效地完成目標；沒有目標卻要保持專注的話不僅困難，還是浪費精力的行為；過多的目標也會使自己茫然無緒，不曉得該先把焦點放在哪一個目標上。 在你尚未開始工作前，請為自己設立幾個目標，並且規畫好要先做哪一件事，將順序排定，如此一來便能一次只專注在一個任務上。如果你沒有事先安排好處理各項任務的前後順序，在上工時你會發現自己困在不知道應該先做什麼的煩惱之中，導致注意力嚴重分散。 以我自己來說，都會先選好當日要進行的任務，若是沒有事先預定那天要完成哪些事項，等到要開始做了才在決定，就會像無頭蒼蠅一樣不知道要做什麼好，陷在五花八門的選項中。後來還發現就連每個項目的處理順序也都要先安排好，否則到時候也會膠著於設定要做的幾個目標上。我幾乎都會將當天一定要做完的事列為第一要務，一定是首先處理的工作，其餘的就依據重要性和時間排程來決定先後順序。 給自己設下限制，按照已排定的順序做事，就不會跟自己討價還價，也能讓注意力集中於正在進行的工作上，如此才能快速有效率地完成任務。 二、消除外部和內部干擾 訂定目標後的首要之務就是事先排除干擾，無論是外部或是內部干擾，事前排除都比事後排除還來得有效；因為只要放任大腦漫無目的地行動，大腦便會被更有趣的事物吸引，因而分心，造成生產力低落。所以事先消除干擾，例如把手機關掉，或是將不必要的網頁關閉，如此大腦就別無選擇，只能專注在任務上。 內在的干擾也是需要控制的，譬如大腦隨機的神遊以及突然冒出的念頭，將這些想法寫下來，能幫助大腦重新專注。研究顯示人的大腦有 47％ 的時間都在神遊，平均需要 22 分鐘才能再度返回工作狀態，所以排除干擾有助於阻止大腦神遊，否則可能需要花費不少時間才能讓大腦恢復專注。 對於這個部分我深有同感，大腦總是會不斷地冒出各種念頭，如同關不住的水龍頭，讓人無法好好地專心做事；所以為了預防這樣的情形出現，我會盡量排除可能的干擾。以前我會一邊寫文章一邊想著其他尚未做的事，或者想著自己訂閱的創作者所發布的新內容，因此寫著寫著就會被這些思維影響而分心；不過現在，我會在寫文章之前就將內容看完，或是先大致瀏覽，至於還沒做的工作就不去想，刻意使自己專心寫完文章才去做其他事，後來發現分心的次數減少了，寫文的速度也變快了。 圖／Estée Janssens on Unsplash 三、把注意力集中在任務上 預先想好自己要專注多久，更有助於進入極度專注的模式。如果前面兩個步驟基礎打得夠深，後續的專注力就更強。能否集中注意力的關鍵就在於你有沒有確實執行前面兩個流程。 四、持續把注意力拉回選定的任務 儘管已經事先移除干擾，偶爾還是會有意外出現打擾我們，這個時候極度專注力就是在我們思緒被打亂或分心時，把注意力拉回到任務上的最佳幫手。只要前面幾道手續都有做好，有將根基打好，極度專注力便能幫助我們搶回被吸引走的注意力。 無論再怎麼完善的計畫，還是會有突如其來的干擾出現、打亂我們的專注力；即便我事先安排好要先專注進行的任務，依照順序並排除可能的干擾，在工作的當下還是會被外頭的聲響或別人的談話拉走注意力，或是被打斷思緒；所以就必須持續地拉回自己的注意力。儘管很難，但我發現，透過一次次拉回專注力的練習，自己就越來越能專注，不會再輕易被搶走注意力。 在需要專注力幫忙之時，先為自己設定一個目標，並且事先消除可能出現的干擾，這兩點是最重要的。如果能就此建立良好的基礎，開啟極度專注模式，讓極度專注力替你拉回神遊的大腦，就不需要懼怕其他人事物來打擾了。 執行編輯：張詠晴核稿編輯：何承祐 Photo Credit：Ashley Knedler on Unsplash原文链接[https://crossing.cw.com.tw/article/12893]","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://zguishen.com/tags/转载/"}]},{"title":"Counting Stars","slug":"58Counting Stars","date":"2021-03-06T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/feeb20a0.html","link":"","permalink":"https://zguishen.com/posts/feeb20a0.html","excerpt":"","text":"Simply Three 这版听起来又有另一种感觉。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"过去半年生活买的一些电子电器产品评价","slug":"57离职半年生活用品用处总结","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/fe306d0f.html","link":"","permalink":"https://zguishen.com/posts/fe306d0f.html","excerpt":"去年七月离职之后，不再需要按上班节奏生活，有了许多时间做自己喜欢做的事情。在这期间也体验了许多有趣的事情，买了一些东西充实生活，有的好用，有的用了几次就吃灰了。","text":"去年七月离职之后，不再需要按上班节奏生活，有了许多时间做自己喜欢做的事情。在这期间也体验了许多有趣的事情，买了一些东西充实生活，有的好用，有的用了几次就吃灰了。 1、华为WATCH GT2（42mm）买42mm版时因为觉得46mm看起来比较丑，42mm的好看，而且自己手腕比较细小的比较适合。续航官方说法一周，实际轻度使用，不开常亮差不多吧，5天充一次可以接受。买这个手表主要是觉得好看，可以检测心率，提醒久坐和跑步计步。其实手环这些功能也一样全都有，就是觉得好看才买。缺点就是跑步的时候想要跟踪运动轨迹，GPS功能实在不行，搜星半天还不怎么准。 2、高漫1060pro 数位板看了网络上那么多大佬画的那么漂亮的图，也想尝试自己画画，最重要的是，想要se图还可以自己，那岂不是好爽……突然有热情就买了，但是绘画真不是简单的事情，不认真学个几年估计画不出像样的东西。不过着东西还能拿来做笔记，看文档的事情做标记做笔记还挺好用的。但是我没这个习惯，用得少，所以这数位板成了吃灰产品。 3、双飞燕 A4TECH FK11小键盘去年11月入职新公司，公司给发了笔记本电脑，但这笔记本这是辣鸡，还特么必须只能用这个笔记本，不能自己带电脑。键盘敲得太难受了就买了这个双飞燕键盘，实际外接键盘个人感觉也没多爽，其实是上班不爽，之后12月离职，宿舍里还有日常用的n年前50块钱买的键盘，个人对键盘没什么需求，还一直用着。现在写这篇文章又把闲置的小键盘拿出来敲敲，其实还不错的，要是出差的时候也能带上不占地方。 4、ZJXED家用电表纯粹玩具了，用来看看电流电压功率的小玩意。 5、实木取暖器烤火器最讨厌的季节是冬天，一冷整个人都不好。这个烤火器用来热脚的，很爽啊，脚暖了人精神好多了。 7、澳柯玛（AUCMA）取暖器 暖风机天气更冷了，身体和手也觉得冷，受不了了再买了这个暖风机。结果广东的冬天很冷的时候也就几天，但是真不能忍。在公司上班的时候就没这么多想法了，公司还是比较暖和的，一闲下来有点冷觉得不行，看来还是要早点重新找工作上班了，没事干平常屁事反而多了。 8、志高H20A6家用电磁炉和煎炒锅一个人生活自己煮饭，电磁炉绝对是神器，怎么就没早点买呢，干啥都行，而且快。一个电饭煲和一个电磁炉加上炒锅就可以做大多数想做的饭菜了。但是这款电磁炉最低的火力都有1100w，想开小火持续煮东西就不怎么好了，调到最低档是开几秒停几秒的模式，勉强能用用。看了小米那款电磁炉调节范围就比较大，可能比较好用，但是这款胜在便宜点，个人也不是非要那么多功能的电磁炉。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"Java开发常用的Linux命令","slug":"56Java开发常用的Linux命令","date":"2021-02-04T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/8ecd9316.html","link":"","permalink":"https://zguishen.com/posts/8ecd9316.html","excerpt":"","text":"系统信息1. uname用于查看系统信息1uname -a 显示全部信息 2. lscpucpu 架构信息 文件和目录操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 12345## ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据-h : 和 -l 一起使用，列出文件同时以合理易读的单位显示文件大小 2. cd更换当前目录。1cd [相对路径或绝对路径] 3. mkdir创建目录。123## mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 4. rmdir删除目录，目录必须为空。12rmdir [-p] 目录名称-p ：递归删除目录 5. touch更新文件时间或者建立新文件。123456## touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm删除文件。12## rm [-fir] 文件或目录-r ：递归删除 8. mv移动文件。123## mv [-fiu] source destination## mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 查看文件内容1. cat取得文件内容。12## cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac是 cat 的反向操作，从最后一行开始打印。 3. more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 4. less和 more 类似，但是多了一个向前翻页的功能。 5. head取得文件前几行。12## head [-n number] filename-n ：后面接数字，代表显示几行的意思 6. tail是 head 的反向操作，只是取得是后几行。常用：12tail -f xx #实时查看tail -100f xx #实时查看最后的一百行 7. od以字符或者十六进制的形式显示二进制文件。 用户和用户组用户添加新的用户账号使用 useradd 命令，删除使用 userdel 命令，修改使用 usermod 命令12useradd 选项 用户名useradd mysql -g mysql #添加 mysql 用户归属 mysql 用户组 12userdel 选项 userdel -r sam #-r的作用是把用户的主目录一起删除 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录 12usermod 选项 用户名usermod -s /bin/ksh -d /home/z –g developer sam 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer 用户组增加用户组1groupadd 选项 用户组 删除用户组1groupdel 用户组 修改用户组1groupmod 选项 用户组 权限操作chmod ［who］ ［+ | - | =］ ［mode］ 文件名命令中各选项的含义为：操作对象who可是下述字母中的任一个或者它们的组合：1234u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是：123+ 添加某个权限。- 取消某个权限。= 赋予给定权限并取消其他所有权限（如果有的话）。 设置mode所表示的权限可用下述字母的任意组合：123456789r 可读。w 可写。x 可执行。X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。t 保存程序的文本到交换设备上。u 与文件属主拥有一样的权限。g 与和文件属主同组的用户拥有一样的权限。o 与其他用户拥有一样的权限。 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 示例：ls -l 命令 查看文件显示12drw-rw-rw- 4 root root 4096 Dec 3 06:05 SSR-Bash-Python-rw-r--r-- 1 root root 22 Jan 11 22:38 test.txt 前面的 drw-rw-rw- 之类 ，第一位含义：普通文件的文件权限第一个字符为“-”目录文件的文件权限第一个字符为“d”字符设备文件的文件权限第一个字符为“c”块设备文件的文件权限第一个字符为“b”符号链接文件的文件权限第一个字符为“s” 后面九位为三个用户组的权限，每个用户组三位，读、写、执行权限为 rwx ，没哪个则哪个为 - ，如 r– 为只读，没有写和执行权限。添加权限方式1、 chmod a+w filename 为所有用户给filename文件增加写(w)权限2、chmod 777 filename 所用用户拥有filename的所有权限 搜索1. which指令搜索。12## which [-a] command-a ：将所有指令列出，而不是只列第一个 2. whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。1## whereis [-bmsu] dirname/filename 3. locate文件搜索。可以用关键字或者正则表达式进行搜索。 压缩和打包压缩文件名Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。经过 gzip 压缩过，源文件就不存在了。有 9 个不同的压缩等级可以使用。可以使用 zcat、zmore、zless 来读取压缩文件的内容。123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2提供比 gzip 更高的压缩比。查看命令：bzcat、bzmore、bzless、bzgrep。12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。查看命令：xzcat、xzmore、xzless、xzgrep。1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 防火墙iptables12开启： chkconfig iptables on 关闭： chkconfig iptables off 即时生效，重启后失效123开启： service iptables start 关闭： service iptables stop 状态 service iptables status firewalld12345service firewalld status; #查看防火墙状态service firewalld start; 或者 #systemctl start firewalld.service;#开启防火墙service firewalld stop; 或者 #systemctl stop firewalld.service;#关闭防火墙service firewalld restart; 或者 #systemctl restart firewalld.service; #重启防火墙systemctl disable firewalld.service#禁止防火墙开启自启 vi/vim 基本操作vi与vim两者区别它们都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。vim的这些优势主要体现在以下几个方面：1.多级撤消我们知道在vi里，按 u只能撤消上次命令，而在vim里可以无限制的撤消。2.易用性vi只能运行于unix中，而vim不仅可以运行于unix,windows ,mac等多操作平台。3.语法加亮vim可以用不同的颜色来加亮你的代码。4.可视化操作就是说vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows。5.对vi的完全兼容某些情况下，你可以把vim当成vi来使用 使用 vi 文件名 或者 vim 文件名 打开文件按i进入编辑按esc退出编辑打开状态操作：12345678910u 撤销上一步操作ctrl+r 恢复上一步被撤销的操作/字符串 搜索字符串:%s/aa/bb 把aa替换成bb编辑状态操作：:w 保存:q 退出，有提示:q! 强制退出:wq 保存退出（强制写入文件并退出）:x 保存退出（有修改时才写入文件并退出） 按esc回到打开状态 其他操作123456gg 回到顶端G 到底端u 撤销 ctrl+r 恢复上一步被撤销的操作ctrl+b 向上翻页ctrl+f 向下翻页 vi操作异常中断提示Found a swap file by the name删除目录下的隐藏文件，恢复操作;ls -a 查看swap隐藏文件，rm 命令删除即可。 进程管理1.ps12345ps -l # 查看自己的进程ps aux # 查看系统所有进程ps aux | grep nginx # 查看特定进程nginxps -ef | grep nginx # 同上pstree -A # 查看进程树 2.top第一行，任务队列信息，同 uptime 命令的执行结果 系统时间：23:46:16运行时间：up 179 days, 11:16,当前登录用户： 1 users负载均衡(uptime) load average: 0.00, 0.02, 0.05 average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了 第二行，Tasks — 任务（进程）总进程:96 total, 运行:1 running, 休眠:95 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie 第三行，cpu状态信息0.3%us【user space】— 用户空间占用CPU的百分比0.5%sy【sysctl】— 内核空间占用CPU的百分比0.0%ni【】— 改变过优先级的进程占用CPU的百分比99.2%id【idolt】— 空闲CPU百分比0.0%wa【wait】— IO等待占用CPU的百分比0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比0.0%si【Software Interrupts】— 软中断占用CPU的百分比 第四行,内存状态8009128 total, 832280 free, 1235088 used, 5941760 buff/cache【buffers缓存的内存量】 第五行，swap交换分区信息0 total, 0 free, 0 used. 6469384 avail Mem【cached缓冲的交换区总量】 备注：可用内存=free + buffer + cached对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。 参考 [1] Linux基本概念及常用命令实现汇总 [2] Linux 命令大全 [3] 鸟哥的 Linux 私房菜","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zguishen.com/tags/Linux/"}]},{"title":"IP地址表示方法","slug":"55IP地址CIDR","date":"2021-01-15T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/45bd0325.html","link":"","permalink":"https://zguishen.com/posts/45bd0325.html","excerpt":"有时会看到一些有关 ip 段的写法是这样的：“192.168.1.1/24”，这种写法叫 CIDR 无类域间路由。“/”后面的数字控制前面 ip 地址的掩码，以表示后面有几位可以变。","text":"有时会看到一些有关 ip 段的写法是这样的：“192.168.1.1/24”，这种写法叫 CIDR 无类域间路由。“/”后面的数字控制前面 ip 地址的掩码，以表示后面有几位可以变。 具体解析如下：网段区间 192.168.1.1/24IP 地址 192.168.1.1，由4段32 bit 组成，即11000000 10101000 00000001 00000001 /24 表示子网掩码前24位为1，后面为0，子网掩码和 IP 地址按位与运算123411111111 11111111 11111111 00000000 11000000 10101000 00000001 00000001 &amp;-------------------------------------------------11000000 10101000 00000001 00000000 十进制为 192.168.1.0，得到网络地址 子网掩码中等于0的部分是后面8位，将网络地址的后8位设置为1，即11000000 10101000 00000001 11111111十进制为 192.168.1.255，得到广播地址 总结IP段 192.168.1.0/24IP段 192.168.1.0 - 192.168.1.255起始IP 192.168.1.1 - 192.168.1.254网络 192.168.1.0掩码 255.255.255.0广播 192.168.1.255可用数 254","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://zguishen.com/tags/基础/"}]},{"title":"冬日","slug":"54冬日","date":"2021-01-02T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/fb832fb5.html","link":"","permalink":"https://zguishen.com/posts/fb832fb5.html","excerpt":"以前对2020年的记忆是课本上的”2020全面建设小康社会“，一晃，2020年已经是历史了。","text":"以前对2020年的记忆是课本上的”2020全面建设小康社会“，一晃，2020年已经是历史了。 在2020年的最后一个月，上班一个多月，试用期期间，我还是选择了离职。说到底就不该入职这个公司，行业并不是自己多喜欢的音视频领域，想尝试坚持试试，但对出差实在反感，还要到长三角那边，这冬天这么冷…… 上周寒流来临，广东也正式进入冬天了。天气一冷，皮肤干燥，行动迟缓，精神萎靡，最蛋疼的是鼻子又要遭罪了，一吹风拼命打喷嚏流鼻水。对冬天真实喜欢不起来。 冬日感觉最舒服的事情就是晒太阳了，一边晒太阳一边喝可乐，真的惬意。 上周去电影院看了《心灵奇旅》，明明买单写的是国语版，去到现场结果播的是英语，本来还想听听国语配音怎么样，看网络上评价还挺不错的。心灵奇旅 Soul (2020) 《心灵奇旅》可以说是给了打工人一碗鸡汤。当你进入憧憬的企业上班，日子久了，突然发现每天重复性的上班劳动，这是我们想要的生活么。”What I want is the ocean.“，鱼要找到大海，殊不知已置身于大海之中。生活虽有波澜起伏，更多时候是风平浪静，没必要一直赶着前进，活在当下更重要。 平静的日子回忆起小时候的时光，还是小时候好玩，不过现在看这番感觉有些幼齿了。悠哉日常大王剧场版：假期活动 劇場版 のんのんびより ばけーしょん (2018)这个星空场景真的美，现在家里乡下也难以见到漫天星星的夜空了。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"【转载】分布式事务，这一篇就够了","slug":"53【转载】分布式事务，这一篇就够了","date":"2020-12-29T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/d8fe79bf.html","link":"","permalink":"https://zguishen.com/posts/d8fe79bf.html","excerpt":"","text":"[作者简介] 李文华，小米信息技术部海外商城组 随着互联网技术的不断发展，系统越来越复杂，几乎所有 IT 公司的系统都已经完成从单体架构到分布式架构的转变，分布式系统几乎无处不在。谈到分布式系统，特别是微服务架构，我们不得不谈分布式事务。今天就跟大家一起聊聊分布式事务以及常用解决方案。 基础理论在讲解具体方案之前，我们有必要了解一些分布式事务所涉及到的基础理论知识。 事务事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。 分布式事务分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。例如在大型电商系统中，下单接口通常会扣减库存、减去优惠、生成订单 id, 而订单服务与库存、优惠、订单 id 都是不同的服务，下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果，这时候分布式事务就保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 强一致性、弱一致性、最终一致性强一致性任何一次读都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。 弱一致性数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。 最终一致性不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。 CAP 原则 CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 一致性（C）： 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）： 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容错性（P）： 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时 C 和 P 两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了 CP 系统，但是 CAP 不可同时满足。 BASE 理论BASE 理论指的是基本可用 Basically Available，软状态 Soft State，最终一致性 Eventual Consistency，核心思想是即便无法做到强一致性，但应该采用适合的方式保证最终一致性。 BASE，Basically Available Soft State Eventual Consistency 的简写：BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。E：Consistency 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。 柔性事务不同于 ACID 的刚性事务，在分布式场景下基于 BASE 理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。 幂等操作在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回调接口在网络正常的情况下无论操作多少次都应该返回成功。 分布式事务使用场景转账转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。此时就会出现 2 种异常情况：1. 用户 A 的账户扣款成功，用户 B 账户余额增加失败 2. 用户 A 账户扣款失败，用户 B 账户余额增加成功。对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。 下单扣库存在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id, 扣减库存等操作，对于微服务架构系统，订单 id 与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功。 同步超时继续以电商系统为例，在微服务体系架构下，我们的支付与订单都是作为单独的系统存在。订单的支付状态依赖支付系统的通知，假设一个场景：我们的支付系统收到来自第三方支付的通知，告知某个订单支付成功，接收通知接口需要同步调用订单服务变更订单状态接口，更新订单状态为成功。流程图如下，从图中可以看出有两次调用，第三方支付调用支付服务，以及支付服务调用订单服务，这两步调用都可能出现调用超时的情况，此处如果没有分布式事务的保证，就会出现用户订单实际支付情况与最终用户看到的订单支付情况不一致的情况。 分布式事务的解决方案两阶段提交/XA两阶段提交，顾名思义就是要分两步提交。存在一个负责协调各个本地资源管理器的事务管理器，本地资源管理器一般是由数据库实现，事务管理器在第一阶段的时候询问各个资源管理器是否都就绪？如果收到每个资源的回复都是 yes，则在第二阶段提交事务，如果其中任意一个资源的回复是 no, 则回滚事务。 大致的流程： 第一阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段 (commit/rollback)：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。 存在的问题： 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。 单点故障：一旦事务管理器出现故障，整个系统不可用 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。 TCC关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点： 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性 TCC(Try Confirm Cancel)Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。 在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。 本地消息表本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者，其大致流程如下： 当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中 系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试 系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作 本地消息表实现的条件： 消费者与生成者的接口都要支持幂等 生产者需要额外的创建消息表 需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作 容错机制： 步骤 1 失败时，事务直接回滚 步骤 2、3 写 mq 与消费 mq 失败会进行重试 步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作 此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 可靠消息最终一致性大致流程如下： A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作 如果消息发送成功，则执行本地事务 如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息 B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求 5.mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息 该方案与本地消息最大的不同是去掉了本地消息表，其次本地消息表依赖消息表重试写入 mq 这一步由本方案中的轮询 prepare 消息状态来重试或者回滚该消息替代。其实现条件与余容错方案基本一致。目前市面上实现该方案的只有阿里的 RocketMq。 尽最大努力通知最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。 这个方案的大致意思就是： 系统 A 本地事务执行完之后，发送个消息到 MQ； 这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口； 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。 分布式事务实战两阶段提交/XA目前支付宝使用两阶段提交思想实现了分布式事务服务 (Distributed Transaction Service, DTS) ，它是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。具体可参考支付宝官方文档：https://tech.antfin.com/docs/2/46887 TCCTCC 需要事务接口提供 try, confirm, cancel 三个接口，提高了编程的复杂性。依赖于业务方来配合提供这样的接口，推行难度大，所以一般不推荐使用这种方式。 可靠消息最终一致性目前市面上支持该方案的 mq 只有阿里的 rocketmq, 该方案应用场景也比较多，比如用户注册成功后发送邮件、电商系统给用户发送优惠券等需要保证最终一致性的场景 本地消息表跨行转账可通过该方案实现。用户 A 向用户 B 发起转账，首先系统会扣掉用户 A 账户中的金额，将该转账消息写入消息表中，如果事务执行失败则转账失败，如果转账成功，系统中会有定时轮询消息表，往 mq 中写入转账消息，失败重试。mq 消息会被实时消费并往用户 B 中账户增加转账金额，执行失败会不断重试。 小米海外商城用户订单数据状态变更，会将变更状态记录消息表中，脚本将订单状态消息写入 mq，最终消费 mq 给用户发送邮件、短信、push 等。 最大努力通知最大努力通知最常见的场景就是支付回调，支付服务收到第三方服务支付成功通知后，先更新自己库中订单支付状态，然后同步通知订单服务支付成功。如果此次同步通知失败，会通过异步脚步不断重试地调用订单服务的接口。 小米海外商城目前除了支付回调外，最常用的场景是订单数据同步。例如系统 A、B 进行数据同步，当系统 A 发生订单数据变更，先将数据变更消息写入小米 notify 系统（作用等同 mq），然后 notify 系统异步处理该消息来调用系统 B 提供的接口并进行重试到最大次数。 总结本文介绍了分布式事务的一些基础理论，并对常用的分布式事务方案进行了讲解，在文章的后半部分主要给出了各种方案的常用场景。分布式事务本身就是一个技术难题，业务中具体使用哪种方案还是需要根据自身业务特点自行选择，每种方案在实际执行过程中需要考虑的点都非常多，复杂度较大，所以在非必要的情况下，分布式事务能不用就尽量不用。 参考： “分布式服务化系统一致性的“最佳实干” https://mp.weixin.qq.com/s/khAwfJvWcwgbAYbBHbU8aQ “常用的分布式事务解决方案” https://blog.csdn.net/u010425776/article/details/79516298?tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_ios&amp;utm_campaign=client_share&amp;wxshare_count=1 “深入分布式事务” http://www.codeceo.com/article/distributed-transaction.html CAP 原则 https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99 事务 https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882 布式事务 https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1 《Atomic Distributed Transactions: a RESTful Design》 作者 李文华，小米信息技术部海外商城组 原文链接[https://xiaomi-info.github.io/2020/01/02/distributed-transaction/]","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://zguishen.com/tags/转载/"}]},{"title":"微服务要点梳理","slug":"52微服务总结","date":"2020-12-21T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/f08cd80.html","link":"","permalink":"https://zguishen.com/posts/f08cd80.html","excerpt":"微服务是一种用于构建应用的架构方案。微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。","text":"微服务是一种用于构建应用的架构方案。微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。 1.实施微服务好处 针对特定服务发布，影响小，风险小，成本低 频繁发布版本，快速交付需求 低成本扩容，弹性伸缩，适应云环境 2.带来的问题 分布式系统的复杂性 部署，测试和监控的成本问题 分布式事务和CAP的相关问题 4.Spring Cloud 组件 注册中心 Eureka，其他的还有 Zookeeper、Consul 和 Nacos。用于服务发现； 配置中心 Spring Cloud Config 网关 Spring Gateway 和 Zuul 客户端负载均衡 Ribbon，默认策略是轮询 断路器 Hystix RPC 客户端 Feign 5.限流方法（流量控制、熔断降级、系统负载保护） Hystrix 熔断策略基于异常比率；限流基于 QPS，支持基于调用关系的限流 sentinel 熔断策略基于响应时间、异常比率、异常数；限流支持有限（并发线程数或信号量大小） Redis + Lua 脚本。 判断 key 是否存在，若不存在设置 key 过期时间和对应 value 为1； 若存在判断在过期时间内 key 对应的 value 值是否大于限制数量，大于返回 false，小于自增加2并返回 true。 6.限流算法 计数器（固定窗口） 滑动窗口（Sentinel） 漏桶（Java 线程池） 令牌桶（Guava RateLimiter） 7.负载均衡方法 随机 轮询 加权响应：响应时间短的权重就大 8.分布式锁 数据库级别：读频繁用客观锁，写频繁用悲观锁 乐观锁：基于版本号实现 悲观锁：基于数据库级别的 for update 基于 Redis 原子性操作，使用 setnx 和 expire 实现 基于 Rdisson 框架实现 基于 Zookeeper，使用 InterprocessMutex 实现 10.CAP理论 Consistency 一致性：写之后的操作，必须返回该值。分布式系统中任意一个节点都会查询到相同的信息。 Availability 可用性：正常响应时间，服务一直可用。只要收到用户请求，服务器就必须做出响应。 Partition tolerance 分区容错性：区之间通讯可能失败，容忍某些区奔溃。当部分节点出现问题的时候，系统依然能正常堆外提供服务。 11.BASE 理论 Basically Available（基本可用） Soft state（软状态） Eventually consistent（最终一致性） 12.分布式事务分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。常用的解决方案有： 基于 XA 协议的 2PC （两阶段提交）和 3PC。Seata 常用模式 基于业务层的 TCC 方案。Try Confirm Cancel 三阶段，代码实现复杂度相对较高 使用应用消息队列 + 本地消息表实现的最终一致性方案。跨行转账可通过该方案实现。目前市面上支持该方案的 mq 只有阿里的 rocketmq，单消息队列可用于： 用户注册成功后发送邮件 电商系统给用户发送优惠券 最大努力通知。例如支付回调和其他一些回调通知 13.分布式事务框架 Seata：提供 AT、TCC、SAGA 和 XA 事务模式 TX-LCN：提供LCN（2pc）、TCC、TXC 三种事务模式 Raincat 14.Seata 4种事务模式（AT、TCC、Saga、XA）模式分析四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景。 AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。 TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。 Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。 XA模式是分布式强一致性的解决方案，但性能低而使用较少。 15.分布式链路跟踪 Spring Cloud Sleuth ZipKin 16.分布式 id 生成方式 UUID 数据库自增 ID 数据库自增 ID 号段模式 Redis 雪花算法","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zguishen.com/tags/面试/"}]},{"title":"Java虚拟机JVM梳理","slug":"51Java虚拟机总结JVM","date":"2020-12-20T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/ffbc902a.html","link":"","permalink":"https://zguishen.com/posts/ffbc902a.html","excerpt":"对于Java开发而言，找工作面试基本上都会问道 JVM 这个知识点，其中涉及结构组成、作用原理、异常排查和参数调优等等。","text":"对于Java开发而言，找工作面试基本上都会问道 JVM 这个知识点，其中涉及结构组成、作用原理、异常排查和参数调优等等。 JVM 是什么Java 虚拟机，Java Virtual Machine 简称 JVM。JVM 主要包括类加载器（ClassLoader）子系统、运行时数据区和执行引擎三部分。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 JVM内存模型 JVM 运行时数据区虚拟机栈栈是线程私有，用来存放局部变量、对象引用和常量池引用。方法执行的时候会创建一个栈帧，存储了局部变量表、操作数栈、动态链接和方法出口信息。每个方法从调用到执行完毕，对应一个栈帧在虚拟机中的入栈和出栈。Java 虚拟机栈会出现两种错误：StackOverFlowError ：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。OutOfMemoryError ： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。 本地方法栈线程私有，和虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务，也会抛出 StackOverFlowError 和 OutOfMemoryError。 程序计数器线程私有，是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果是 Native 方法，则为空。 堆线程共享，在虚拟机启动的时候创建，用于存放对象实例。通过-Xmx 和-Xms 来控制大小。分为新生代、老年代。（方法区中的永久代在 JDK 1.8及之后已经移除）。新生代可分为 Eden 空间、From Survivor 和 To Survivor 空间等。堆容易出现的错误是 OutOfMemoryError 错误，表现有几种： OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！) 方法区线程共享，存储要加载类信息、静态变量、final 类型的常量、属性和方法信息。永久代是方法区的一种实现，JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：12-XX:PermSize=N //方法区 (永久代) 初始大小-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常 `java.lang.OutOfMemoryError: PermGen` JDK 1.8及之后永久代被彻底移除了，取代的是元空间，元空间使用的是直接内存，常用设置参数：12-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 永久代 (PermGen) 替换为元空间 (MetaSpace)原因是永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，只受本机可用内存的限制。元空间也会溢出，但比原来出现的几率小。运行时常量池也在方法区中。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用。常量池中存放的是对象引用，而不是真实的对象。JDK1.7 之前的运行时常量池，包含字符串常量池存放在方法区，JDK1.7 开始把字符串常量池和静态变量从方法区拿到了堆中。到 JDK1.8 使用元空间替代永久区来实现方法区，此时运行时常量池在元空间，字符串常量池在堆，但逻辑上讲这两个都在方法区。 GC 垃圾回收判断对象是否需要回收 引用计数法：难解决对象循环引用问题 根搜索法（可达性算法）：从GC Roots对象开始向下搜索，如果一个对象到GC Roots对象没有关联，则可以回收。可最为GC Roots的对象有： 虚拟机中的局部变量 方法区或堆中的静态变量、常量引用对象 本地方法引用对象 GC 回收算法 标记-清除算法：先标记需要清除对象，然后遍历清除。不需要移动对象，缺点是容易产生内存碎片。 复制算法：将可用内存分为两块，把存活对象复制到另一块内存上，再把第一块内存所有对象清除。不易产生内存碎片，每次只需回收半个区，但同时内存空间也缩减为原来的一半；算法效率和存活对象的树木相关，存活对象越多，效率越低。 标记-整理算法：结合“标记-清除”和“复制”两个算法的优点，将标记的存活对象都向一端移动，清理端边界以外的内存 分代收集算法：目前大部分Java虚拟机垃圾收集器采用的算法。根据对象的生命周期将内存划分为多个的区域，不同区域适用不同的收集算法。 年轻代：一般大量对象产生快，消亡也快。采用复制算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。 老年代：存储的对象比年轻代多得多，而且不乏大对象。采用标记-整理算法，标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设 置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。 永久代（JDK1.8移除）：常量池中的常量和无用的类信息回收。永久代回收不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制。 GC类型 Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC； Full GC（Major GC）：Major GC 是清理永久代。Full GC 是清理整个堆空间—包括年轻代和永久代，事实许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。知道 Full GC 就行了。 垃圾回收器Serial收集器新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）； ParNew收集器新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数； Parallel Scavenge 收集器新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间； Serial Old收集器老年代收集器，单线程收集器，使用标记-整理算法； Parallel Old收集器老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记-整理算法； CMS（Concurrent Mark Sweep）收集器老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。CMS收集的方法是：先3次标记，再1次清除，3次标记中前两次是初始标记和重新标记（此时仍然需要停止（stop the world））。 初始标记（Initial Remark）是标记GC Roots能关联到的对象（即有引用的对象），停顿时间很短； 并发标记（Concurrent remark）是执行GC Roots查找引用的过程，不需要用户线程停顿； 重新标记（Remark）是在初始标记和并发标记期间，有标记变动的那部分仍需要标记。所以加上这一部分标记的过程，停顿时间比并发标记小得多，但比初始标记稍长。在完成标记之后，就开始并发清除，不需要用户线程停顿。在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 G1（Garbage-First）收集器G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。 支持多CPU和垃圾回收线程 整体采用标记-整理算法，局部是通过是通过复制算法，不会产生内存碎片（与CMS相比，CMS标记的时候也有可能产生垃圾，会有内存碎片） 宏观上看 G1 之中不再区分年轻代和老年代，内存划分为多个独立的子区域。但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代 在主线程暂停的情况下，使用并行收集 在主线程运行的情况下，使用并发收集 JVM 调优JVM调优是比较高深的学问，包括设置合理的内存参数，选择合理垃圾回收器甚至修改 JVM 代码等等。在一般项目中很少会去做具体调优。比较常用简单的优化： 堆设置合理的-Xmx 和-Xms大小，一般两个值设为一样，避免每次 GC 后调整堆的大小； 设置新生代和老年代比例； 开启 GC 日志，查看 GC 情况，排查解决 Full GC 频繁原因； 使用 Jconsole 监控工具监控线程和堆空间分配。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zguishen.com/tags/面试/"}]},{"title":"【转载】不可不说的Java“锁”事","slug":"50【转载】不可不说的Java“锁”事","date":"2020-12-19T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/86818cd5.html","link":"","permalink":"https://zguishen.com/posts/86818cd5.html","excerpt":"","text":"2018年11月15日 作者: 家琪 文章链接 13658字 28分钟阅读 前言Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录： 1. 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 根据从上面的概念描述我们可以发现： 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例： 12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。 CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义： 根据定义我们可以看出各属性的作用： unsafe： 获取并操作内存的数据。 valueOffset： 存储value在AtomicInteger中的偏移量。 value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。 接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码： 123456789101112131415161718192021222324// ------------------------- JDK 8 -------------------------// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 2. 自旋锁 VS 适应性自旋锁在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。 在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。 首先为什么Synchronized能实现线程同步？ 在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。 Java对象头synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点： 锁状态 存储内容 存储内容 无锁 对象的hashCode、对象分代年龄、是否是偏向锁（0） 01 偏向锁 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） 01 轻量级锁 指向栈中锁记录的指针 00 重量级锁 指向互斥量（重量级锁）的指针 10 无锁 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁 升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 整体的锁状态升级流程如下： 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 4. 公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： 接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。 根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。 下面我们来看一下公平锁与非公平锁的加锁方法的源码: 通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 5. 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(\"方法1执行...\"); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(\"方法2执行...\"); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 6. 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 下图为ReentrantReadWriteLock的部分源码： 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 了解了概念之后我们再来看代码，先看写锁的加锁源码： 123456789101112131415161718protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); // 取到当前锁的个数 int w = exclusiveCount(c); // 取写锁的个数w if (c != 0) &#123; // 如果已经有线程持有了锁(c!=0) // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败 return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 throw new Error(\"Maximum lock count exceeded\"); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。 return false; setExclusiveOwnerThread(current); // 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者 return true;&#125; 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 结语本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。 其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。 参考资料 《Java并发编程艺术》 Java中的锁 Java CAS 原理剖析 Java并发——关键字synchronized解析 Java synchronized原理总结 聊聊并发（二）——Java SE1.6中的Synchronized 深入理解读写锁—ReadWriteLock源码分析 【JUC】JDK1.8源码分析之ReentrantReadWriteLock Java多线程（十）之ReentrantReadWriteLock深入分析 Java–读写锁的实现原理 作者简介 家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://zguishen.com/tags/转载/"}]},{"title":"夜空中最亮的星","slug":"49star","date":"2020-12-16T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/25d4f6f2.html","link":"","permalink":"https://zguishen.com/posts/25d4f6f2.html","excerpt":"","text":"夜空中最亮的星，请指引我前行。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"Github Actions deploy Hexo blog","slug":"48Github Actions deploy Hexo blog","date":"2020-12-15T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/a5d4fd44.html","link":"","permalink":"https://zguishen.com/posts/a5d4fd44.html","excerpt":"","text":"新建分支或 git 库存放 Hexo 源文件 折腾一下把 Hexo 网站用 Github Actions 进行自动化部署，基本流程是这样的 master：主干是原来的静态网站资源，也就是 hexo 编译后 public 下的文件； hexo-blog：新建一个分支，放 hexo 的源文件，包括配置、主题和 markdown 文本等。 流程就是我们写 markdown 文章后，就推送到 hexo-blog 分支，触发 Github Actions 进行自动化部署编译，并把编译完的资源推送到 master 分支，这就完成一次 Hexo 博客的更新。 这里用的是新建 hexo-blog 分支放 Hexo 源文件，新建一个 git 库也是可以，当然 Github Actions 也是在新建的 git 库上。 配置公私密钥 因为涉及代码的 ssh 推送等交互，所以需要设置私钥和公钥。这里因为是用一个 git 库两个分支来做的，所以公私钥都在当前 git 库设置，如果用的是新建 git 库存放 Hexo 源文件，那私钥要放在 Hexo 源文件 git 库，公钥放在静态网站库上。 生成密钥 1ssh-keygen -t rsa -b 4096 -C \"xx@xx.com\" -f github-deploy-key -N \"\" 生成两个文件： github-deploy-key.pub 公钥 github-deploy-key 私钥 打开 https://github.com/xxx/xxx.github.io/settings/keys 填写公钥，xxx github 用户名 Title 输入 HEXO_DEPLOY_PUB （自定义名称，后面自动化部署脚本用到，一致就行） Key 输入生成的 github-deploy-key.pub 的内容 勾选 Allow write access 用于推送分支 打开 https://github.com/xxx/xxx.github.io/settings/secrets/actions 填写私钥（新建git库方式私钥在新建git库上设置） Name 输入 HEXO_DEPLOY_PRI Value 输入生成的 github-deploy-key 的内容 自动化部署脚本 在 hexo-blog 分支根目录下创建 .github 文件夹再进去创建 workflows 文件夹再创建 HexoCI.yml 文件 编辑 HexoCI.yml 文件，内容找个别人的抄来用，https://blog.csdn.net/xinruodingshui/article/details/105499161#t4 12345678910111213141516171819202122232425262728293031323334name: CIon: push: branches: - hexo-blog ##分支名jobs: build: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v1 with: ref: hexo-blog ##分支名 - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Setup hexo env: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; run: | mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.email \"zguishen@foxmail.com\" git config --global user.name \"zguishen\" npm install hexo-cli -g npm install - name: Hexo deploy run: | hexo clean hexo d 构建结果 Actions 里可以看到每次构建流程，失败的可以进去查看日志定位问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zguishen.com/tags/博客/"}]},{"title":"但行好事，莫问前程","slug":"47但行好事，莫问前程","date":"2020-09-01T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/ed4fd972.html","link":"","permalink":"https://zguishen.com/posts/ed4fd972.html","excerpt":"“所有漂泊的人生都梦想着平静、童年、杜鹃花，正如所有平静的人生都幻想伏特加、乐队和醉生梦死。” 现在是2020年9月份，今年已经过去了四分之三，离职两个月，毕业工作四年，在广州八年了。酸甜苦辣各有尝过，但没丢过生活的信心，但现在感觉已经陷入了迷雾之中，不知道该往哪里走。 有的人希望能平静度过一生，有的人渴望轰轰烈烈地活着，但是还有的人，对生活失去所有的兴趣，不知道生活的意义是什么，更甚者选择结束自己生命。","text":"“所有漂泊的人生都梦想着平静、童年、杜鹃花，正如所有平静的人生都幻想伏特加、乐队和醉生梦死。” 现在是2020年9月份，今年已经过去了四分之三，离职两个月，毕业工作四年，在广州八年了。酸甜苦辣各有尝过，但没丢过生活的信心，但现在感觉已经陷入了迷雾之中，不知道该往哪里走。 有的人希望能平静度过一生，有的人渴望轰轰烈烈地活着，但是还有的人，对生活失去所有的兴趣，不知道生活的意义是什么，更甚者选择结束自己生命。 去年年底公司已经取消班车，也没有给点交通补贴，从此开始挤公交的生活。工作项目上人员和业务变动，甲方换人，事情越来越多而且混乱，奇葩需求随便提，越感身心疲惫，感觉也是到了离开的时候。 六月初提出离职，交接了一个月，七月三日从就职将近三年的公司离职，到现在九月，时间过了四个月。但是这四个月过去了，我依然没想好自己到底要干什么。毕业四年，尝试出去面试，才发现现在招聘市场不再像以前那么景气，但要求越高了，自身水平赶不上，觉得自己是个five，想努力一把，但永远认真不起来。 从小身体不好，性格孤僻，虽然日子清苦，但至少没有什么大风大浪。按部就班大学毕业，进入企业上班，自己从来不是那优秀的一波人，比上不足，比下有余。害怕失去一切却又渴望改变，整个人都是矛盾的。 今天在v2上看到一个帖子（https://www.v2ex.com/t/703468 ），没想到有不少人也是一样的状态，许多网友也给出了很好意见。 其实归根到底的原因是自己不够强，人生的许多决定都是处于被动中，一路走来都是被人推着走。生活没有什么大目标，赚不到大钱但也饿不死。与其抱怨时代背景下阶级的固化，竞争的激烈，不如干脆暂时不想，找个事做先让自己忙起来。祝愿自己早点走出困境，找到目标。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"省博物馆","slug":"广东博物馆","date":"2020-07-15T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/b354297a.html","link":"","permalink":"https://zguishen.com/posts/b354297a.html","excerpt":"之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。","text":"之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"2020年3月","slug":"2020年3月","date":"2020-03-26T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/e042aa0.html","link":"","permalink":"https://zguishen.com/posts/e042aa0.html","excerpt":"现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。","text":"现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。 去年9月初婆婆去世，得知消息居然没有那么多悲伤，更多的是麻木了，人说没就没了，而我们什么也做不了。每次想起家人的离去还是难受，奶奶是最疼我最关心我的人，每逢节日都会问我回不回家，而我平常却很少打电话问好，现在想起来甚是后悔。 9月份公司部门旅游我没心情参加，这段时间以来每天浑浑噩噩,上班都要应对处理各类乱七八糟的需求，下班也需要应对线上随时可能出现的问题，甲方越来越离谱，上班不开心，很不开心，不该在外包项目待这么长时间。想忍到新年过后离职重新找工作，结果新冠疫情爆发，各地封锁甚至封城，各行业有的停产有的关门，大量线下门店因此破产倒闭。进而导致许多人都降薪或者被裁了。相反的某些互联网线上业务却因此火爆起来，这段时间在家办公，加班加点赶项目反而比在公司上班更累，007工作时间，24小时 on call ，还好目前疫情总算稳定，可以到公司上班了。新年就如此艰难，2020注定给人们留下深刻的记忆。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"Mysql清除错误临时表","slug":"mysql清除错误临时表","date":"2019-09-25T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/85573622.html","link":"","permalink":"https://zguishen.com/posts/85573622.html","excerpt":"去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。","text":"去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。这是当时的日志 当时就把进程 kill 掉了，但是留下了一个 75G 没有用的临时表，后来因为服务器加了硬盘空间，就没有去管它。最近硬盘又快占满，这个 75G 废弃文件实在碍眼，就着手看看怎么安全删除。 首先暴力 rm 必定不可取，参考互联网资料，这个应该是官方的一个解决方案https://mariadb.com/resources/blog/get-rid-of-orphaned-innodb-temporary-tables-the-right-way/ 试着按参考链接执行建同名表，正常建表命令肯定不会影响数据库，找到原来的表结构建表CREATE TABLE #sql-5df6_36c ( id bigint(32) NOT NULL AUTO_INCREMENT, card varchar(50) DEFAULT NULL COMMENT ‘卡券号’, createTime datetime DEFAULT NULL COMMENT ‘创建时间’, status varchar(1) DEFAULT NULL COMMENT ‘状态’, posData text COMMENT ‘POS请求的数据’, ffData text COMMENT ‘飞凡返回的data’, reason varchar(500) DEFAULT NULL, PRIMARY KEY (id), KEY card_index (card)) ENGINE=InnoDB AUTO_INCREMENT=152943355 DEFAULT CHARSET=utf8; 结果残缺的 #sql-5df6_36c.frm 被自动删掉 接下来剩下缺失表结构的大文件cp cc_card_log.frm /app/mysql/data/watsons_coupon/#sql-ib2460-3936078760.frm复制表结构命名与临时表相同 再 drop 表，提示表不存在 先再建表 可以看到与临时表同名多会生成这两个文件，原来的两个文件也还在的 再试试 drop 表 发现不行，四个文件都还在再尝试 @0023sql@002dib2460@002d3936078760 两个文件倒是删掉了 #sql-ib2460-3936078760 两个还好好的仔细一看 #sql-ib2460-3936078760.frm 用户组用户都是 root ，cp 的时候用了 sudo 执行，需要授权用户 chown mysql:mysql #sql-ib2460-3936078760.frm 再 drop 表 75G文件5s多drop掉，总算删掉了","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/tags/技术/"}]},{"title":"20190812-20190819","slug":"20190812-20190819周报","date":"2019-08-18T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/9727cb5.html","link":"","permalink":"https://zguishen.com/posts/9727cb5.html","excerpt":"","text":"《漫威蜘蛛侠》白金纪念。能力越大，责任越大。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"20190805-20190811周报","slug":"20190805-20190811周报","date":"2019-08-11T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/a83f3ead.html","link":"","permalink":"https://zguishen.com/posts/a83f3ead.html","excerpt":"","text":"最近公司的版本管理工具从 svn 迁移到 git ，总算告别了五六个需求混在一起，只上线部分的麻烦问题。不够 git 毕竟不熟悉，经常切着分支就搞错了，什么变基操作，fetch、merge 和 pull 的用法区别等等其他东西的还是很生疏。 离职真需要下很大的决心，几个月之前就一直想要离职了，想着准备好出去面试一波。但是准备准备着就懈怠了，一天工作下来晚上根本就不想动了。叫我再去学习敲代码刷 LeetCode 太累了，刷番剧看沙雕视频喝快乐水实在太快乐了233，但是一想到工资就快乐不起来了。 最近流行玩蚂蚁森林养小鸡，同事纷纷加我好友，嗯，好吧，小鸡天天被揍，能量天天被头。他们玩得也太疯了吧，还买摇步器刷步数攒能量，还抓那啥妖怪来的。 电视剧《长安十二时辰》已经播到尾声了，这部剧大家都夸道具化妆太好了，力求还原唐时代元素。随着剧情的发展，人物的刻画也逐渐鲜明，可以看到大家对龙波（萧规）和张小敬的态度反转，从一开始认为龙波是个来破环长安的坏人，慢慢地理解他的行为，而张小敬的行为反而慢慢不被理解，许多人都认为长安已经腐朽，不值得去守护了。但是，如果冷静下来看看两人的行为，龙波用现代的词语来说就是一个彻头彻尾的恐怖分子，不应该为他叫好。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"Nginx升级","slug":"Nginx升级","date":"2019-08-05T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/b3e041fa.html","link":"","permalink":"https://zguishen.com/posts/b3e041fa.html","excerpt":"内网的nginx扫出几个漏洞，要求隐藏版本号，解决整型溢出问题，建议升级修补一下。","text":"内网的nginx扫出几个漏洞，要求隐藏版本号，解决整型溢出问题，建议升级修补一下。先 sudo su 用root权限，查看当前版本，再备份 1234[root@CNINUATOTSWEB nginx-1.16.0]# /usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.10.1built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)configure arguments: 解压新版本 tar -zxvf nginx-1.16.0.tar.gz 配置参数（configure arguments后面的参数，没有不填） ./configure make 编译（完成之后切记别 make install） 备份旧版本（最重要的 conf文件 记得备份到本地） mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old 复制 objs 下新版到 sbin 目录 cp objs/nginx /usr/local/nginx/sbin/ 最后执行 make upgrade 替换老的nginx进程 再执行 nginx -V 查看是否成功 隐藏版本号，编辑 nginx.conf, http 下加上server_tokens off;123456789101112http &#123; include mime.types; default_type application/octet-stream; server_tokens off; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;...#以下略","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zguishen.com/tags/nginx/"}]},{"title":"20190729-20190804周报","slug":"20190729-20190804周报","date":"2019-08-03T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/b3ccf6f3.html","link":"","permalink":"https://zguishen.com/posts/b3ccf6f3.html","excerpt":"打算自本周开始，每周都要记录过去的一周做了什么事情，内容包括职业技术上的事情和遇到的问题，但不限于生活上的各种琐事，或许平常生活内容才会更多，稳定的工作工作内容千篇一律。","text":"打算自本周开始，每周都要记录过去的一周做了什么事情，内容包括职业技术上的事情和遇到的问题，但不限于生活上的各种琐事，或许平常生活内容才会更多，稳定的工作工作内容千篇一律。 为什么要记录自从毕业以来已经快三年了，平时工作生活都是“两点一线“，早上做班车到公司上班，傍晚做班车回宿舍，而且是一个人(单身狗)生活。白天上班，晚上自闭玩主机游戏刷电视剧，突然想起一张图真是我的真实写照，”我一条狗，吃饭旅行，走走停停“。 真很难想象这样一直浑浑噩噩走下去会发生什么，或许会变成一个孤僻的疯子吧。最近在 v2 上看到站长新开的周报节点以及所写的一些观点，可以把自己一段时间的事情记录下来，即便是流水账的陈述也无妨。从日常记录引申出的所思所想，回顾一些之前的生活，证明我还活着，活得清楚，然后如何活得清楚简单，而不是一塌糊涂。 这周做了什么周一工作很快就做玩了，只是简单的查询页面和接口。下午和几个前同事的吃大餐聚会又鸽了，每个人都很忙啊，出来吃个饭都不好凑到刚好都有时间出来，就我一个闲人。 周二之后都没需求可做，想着一直以来都没系统学过 Linux ，遂找了下 鸟哥的私房菜 （找到的一个简体的镜像站）教程看看学学，不过相对的比较老了。 看了卓叔的增重微信公众号种草了增肌粉，许多年了想长胖都长不胖，死马当活马医，下单试试有没效果，增重需要配合锻炼，不知我能坚持多久。 在 PS4《漫威蜘蛛侠》中的纽约市荡来荡去实在太爽了，本体剧情也足够优秀，不过开坑一个月我才玩到40%进度，还好是线性剧情向游戏，通主线算休闲，白金看起来就有点蛋疼了，有些刷刷刷的任务真不想做。 周末翻出闲置的小米4C，想着能做什么用，做时钟，一直亮屏浪费电，而且小王子出了名的续航差，渣渣808处理器；想搞个 Linux 玩又用不着，云上已经有了，出公网也是问题，不想玩了；现在用的路由功能太简单，想拿来做全局路由折腾酸酸去广告，那我为什么不出掉换个新路由得了。然后我就把它闲鱼出掉了（笑哭），这还是我第一次用闲鱼，没多久就有人直接拍下付款，好快，难道我挂的价钱太好了么（3+32配置150出掉）。买家一看就是个二手贩子啊，不过信誉评价还可以，这次交易不知道会不会翻车呢……","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"SpringBoot打包和部署(补充)","slug":"SpringBoot打包部署(补充)","date":"2019-01-01T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/d6bdd4db.html","link":"","permalink":"https://zguishen.com/posts/d6bdd4db.html","excerpt":"","text":"SpringBoot 工程若用简单的 clean package 命令打包会包含所有依赖 jar 包，如果工程依赖比较多的时候，打的包通常动不动就几十 m 大。这使得在部署到远程的时候，如果你的网络是小水管的就要传半天了，而且上微服务的项目，多个工程，一个工程还多台机器，更新部署需要浪费许多时间。 SpringBoot 启动可以以加载外部依赖目录来启动工程，所以我不必每次打包都包含一堆 jar 包，只需要把 jar 统一放一个目录，启动时指定依赖目录启动就行。 在网上搜索各类资料和博客，大多以下方式打包。以 maven 打包为例，使用 SpringBoot 打包插件先正常打包12345678910111213141516171819202122232425262728&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;!-- 依赖变化去掉打包重新传完jar包后再打开打包 --&gt; &lt;!-- &lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; --&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 打包后的目录结构，将 lib 目录的依赖包拷贝出来上传到服务器，依赖一般很少改动，若依赖改变重新传一次 打开 include nothing 的配置注释重新打包 1234&lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt;&lt;/include&gt; 打包后的文件，很小了，不用每次部署都传大文件 另外也可以直接用 maven maven-dependency-plugin 插件直接把 jar 包拷贝到目标目录，不需要去包里拷贝，更直接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;!-- 不含依赖 --&gt; &lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 拷贝依赖jar包到target/lib --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;type&gt;jar&lt;/type&gt; &lt;includeTypes&gt;jar&lt;/includeTypes&gt; &lt;includeScope&gt;runtime&lt;/includeScope&gt; &lt;outputDirectory&gt; $&#123;project.build.directory&#125;/lib &lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 启动指定 lib 目录，java -Dloader.path=/app/demo/lib -jar demo-*.jar以发行包和 lib 依赖目录都在 /app/demo 目录下为例，启动的参考脚本，jvm 及其他参数自行加上，注意你的进程名，别把其他进程也 kill 了12345678910111213141516171819202122232425262728293031323334#!/bin/shworkdir=/app/demostart() &#123; cd $workdir nohup java -Dloader.path=\"lib/\" -Xms512m -Xmx1024m -jar demo-*.jar &gt; demo.out 2&gt;&amp;1 &amp; echo \"demo service has started.\"&#125;stop() &#123; pid=`ps -ef | grep 'demo-' | grep -v grep | awk '&#123; print $2 &#125;'` echo $pid kill -9 $pid echo \"demo service has stoped.\"&#125;case \"$1\" in start) start ;; stop) stop ;; restart) stop start ;; *) echo \"Usage: ./demo.sh &#123;start|stop|restart&#125;\" exit 1esacexit 0 保存为 demo.sh授权755 chmod 755 demo.sh启动 ./demo.sh start查看日志输出 tail -20f /app/demo/demo.out","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zguishen.com/tags/Spring/"}]},{"title":"Mysql切换表和删除大表操作备忘","slug":"Mysql切换表和删除大表操作备忘","date":"2018-12-14T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/105f2761.html","link":"","permalink":"https://zguishen.com/posts/105f2761.html","excerpt":"线上有一张日志表累计了太多数据，占用了服务器100多G的内存，需要把历史的数据清除掉，腾出空间。直接删除表的记录 Mysql 是不会自动归还硬盘空间的，需要对表进行 OPTIMIZE TABLE 优化操作归还空间，但此操作会长时间锁定表，不能在线上随便操作。","text":"线上有一张日志表累计了太多数据，占用了服务器100多G的内存，需要把历史的数据清除掉，腾出空间。直接删除表的记录 Mysql 是不会自动归还硬盘空间的，需要对表进行 OPTIMIZE TABLE 优化操作归还空间，但此操作会长时间锁定表，不能在线上随便操作。另一种方式就是新建一张新的表结构与日志表相同，把新的表表名互换，切到新表。之后就可以把占空间大的旧表删除，由于 drop 操作删除表会有锁影响数据库其他操作，而且如果是普通硬盘删除100多G数据也不会很快，会影响服务器IO操作。因此，删除大表一般使用网络上大多人推荐的建立硬链接来进行删除的方式。 切换表操作建表 cc_card_log_1206 ，结构与表 cc_card_log 完全相同,把表 cc_card_log_1206 相互切换表名 cc_card_log，锁写操作，互换表名，解锁。 1234LOCK TABLES cc_card_log WRITE, cc_card_log_1206 WRITE;ALTER TABLE cc_card_log RENAME TO cc_card_log_120601;ALTER TABLE cc_card_log_1206 RENAME TO cc_card_log;UNLOCK TABLES; 删除大表要删除的表已经很大 可以利用硬链接和 truncate 降低 drop table 对线上环境的影响创建方法都很简单：软链接（符号链接） ln -s source target硬链接 （实体链接）ln source target 使用此办法前提条件，需要开启独立表空间，如果是共享表空间无法使用改方法。查询 show variables like &#39;innodb_file_per%&#39;\\G，结果值是 ON 表明开启了。 开启独立表空间表文件就都是单独的 建立硬链接 ln cc_card_log_1206.ibd cc_card_log_1206.ibd.hdlk ，之后 cc_card_log_1206.ibd 的 INODES 属性变成了2，变成2之后 drop table 就不会直接把文件删除了，只是删除了链接，避免对数据库的影响，最后再把 cc_card_log_1206.ibd 删除掉就行了。 drop 删除表 物理上删除表，这里用 truncate 命令直接清空文件也可以，执行 truncate -s 0 cc_card_log_120601.ibd.hdlk","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/tags/技术/"}]},{"title":"域名更换注册商","slug":"域名更换服务商","date":"2018-10-13T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/bdfcfc20.html","link":"","permalink":"https://zguishen.com/posts/bdfcfc20.html","excerpt":"域名不论是新注册、续费和转移，不同的注册商的定价和提供的服务都不一样。有些注册商对新注册域名有比较大的优惠，但续费的就不是那么便宜，还好域名是可以转移到别的注册商，所以给我们的选择就比较多了。","text":"域名不论是新注册、续费和转移，不同的注册商的定价和提供的服务都不一样。有些注册商对新注册域名有比较大的优惠，但续费的就不是那么便宜，还好域名是可以转移到别的注册商，所以给我们的选择就比较多了。 一般在哪个注册商注册域名考虑的方面有：价格：要快速知道各注册商的域名定价，可以到一些域名比较网站看看，比如 www.domcomp.com ；备案情况：许多人建博客喜欢用 .me、.im 域名，但这些域名现在国内是无法备案的，所以只能选择国外的注册商；whois ：不少注册商都有提供免费的 whois 隐私保护功能；dns ：域名解析功能，不同注册商也有所区别。例如这次我从 Namecheap 转到 Porkbun ，Porkbun 并没有找到二级域名重定向到顶级域名功能，比如把 www 定向到顶级域名，只支持重定向到另一个域名。 一般域名的转移步骤都是一样的：首先原注册商解锁域名，停掉 whois ；然后就是 transfer 操作了，注册商会给你生成一个转让授权码；接着到新的注册商进行转入，需要用到原注册商授权码；最后一般等个5天，如果原注册商一直没确认，你的域名就会就会自动转到新的注册商，当然有的注册商有给你转出同意的选择就比较快。所以照这个时间，转移域名一般在到期前的一周操作就行。 这次 transfer 只买了一年，选择了 Porkbun 。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"星球大战","slug":"星球大战","date":"2018-02-22T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/f4533c52.html","link":"","permalink":"https://zguishen.com/posts/f4533c52.html","excerpt":"","text":"趁着春节，把星球大战系列电影刷了一遍，除了最后一部《星球大战：最后的绝地武士》还没正版资源，所以还没看。星战电影拍摄时间线比较有意思的是先拍了正传的三部，后来才补全拍的几部前传。虽然从1977年正传第一部到2017年第八部，跨度40年，电影技术与时俱进，但早年的几部也经过了重制，特效和观影效果不至于看起来太尴尬。系列电影让人感触的是，随着一部部作品的发展，角色的命运也被慢慢揭示。甚至，扮演这些角色的演员，由于他们所扮演的角色成为自己的另一个符号，被世人所熟知，比如我们的莱亚公主。而且，他们的命运也跟戏里的角色有了关联，这样想起来，编剧也是个不得了的工作呢。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"天河公园","slug":"tianhe","date":"2017-10-07T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/dea1ab61.html","link":"","permalink":"https://zguishen.com/posts/dea1ab61.html","excerpt":"","text":"跑跑步…","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"闭包","slug":"闭包","date":"2017-09-11T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/f9636392.html","link":"","permalink":"https://zguishen.com/posts/f9636392.html","excerpt":"在Web开发中，在使用JavScript时，就算没用过，也听说过闭包这个名词。闭将外部作用域中的局部变量封闭起来的函数成为闭包，本质就是一个函数。","text":"在Web开发中，在使用JavScript时，就算没用过，也听说过闭包这个名词。闭将外部作用域中的局部变量封闭起来的函数成为闭包，本质就是一个函数。闭包的作用 保护函数内变量的安全，不能被外部随意修改，只能通过制定函数接口操作 在内存中维持变量，不会被销毁，所以弊端是滥用可能造成内存泄漏 例子123456789101112131415function fun() &#123; var num = 9; add = function() &#123; num++; &#125; function clo() &#123; return num; &#125; return clo;&#125;//add();//这里还不能执行var f = fun();//获得闭包函数add();//操作num的值var value = f();//执行函数获取局部变量num的值 11 以上例子最终的 value 值就是局部变量 num 的值， clo 函数就是闭包。我们无法直接访问 num 变量，但根据Javascript的链式作用域，对于 clo ， fun 内部的所有内部变量都是可见的，所以只要把 clo 作为返回值就可以在外部访问 num 内部变量了。add 函数在这里是一个全局变量，在Javascript中，在函数中变量定义不加上 var 或者其他类型，会被视为全局变量，但要在函数执行后得到声明才能使用，如下123456function test() &#123; var i = 1;//局部 j = 2;//全局，执行test函数时声明，之后全局可用&#125;test();console.log(j) 所以在 fun 函数执行后声明完成，就可以在外部执行，由于闭包 clo 维持了 num 变量，所以在外部 add 函数修改的 num 跟在 fun 函数中 num 的是同一个。 事实上， num 变量在函数中有点类似 Java 中的私有变量，外部不能直接访问，而需要函数内部其他方法访问。以函数对象写另一个例子123456789101112131415161718var fun = function() &#123; var age = 23; var name = \"shen\"; this.getAge = function() &#123; return age; &#125; this.getName = function() &#123; return name; &#125; this.setAge = function() &#123; age++; &#125;&#125;var ff = new foo();//ff.age;//访问不到局部变量ff.setAge();console.log(ff.getAge())//24console.log(ff.getName())//shen 在 Java 中，也有类似的闭包实现存在，匿名内部类就是一个例子，它可以访问外部类的成员变量（相当于第一个例子的clo函数可以访问fun函数的num变量）。但是，由于Java无法保证内部类使用的外部类的局部变量在内外部类同步都指向同一基本类型数据或对象，因为Java只是把外部类的变量做一个拷贝丢给了内部类另一个变量而已。所以，只能干脆限制在内部类访问的外部类变量必须定义为 final 类型，即初始化后就不能修改接口123public interface Cat&#123; public void eat();&#125; 测试类123456789101112131415161718192021222324252627public class Test &#123; public void eatSomething() &#123; //final int num = 10; int num = 10;//final默认可以不写，但当你尝试对num进行操作，比如num++之类，编译器会报错（环境Java8） Cat a = new Cat() &#123; @Override public void eat() &#123; System.out.println(\"eat \" + num + \" fish\");//访问外部num变量 &#125; &#125;; a.eat(); &#125; //Java8支持更简便的Lambda表达式 public void LambdaEatTest() &#123; int num = 10; Cat cat = ()-&gt;System.out.println(\"eat \" + num + \" fish\"); cat.eat(); &#125; public static void main(String[] args) &#123; new Test().eatSomething(); new Test().LambdaEatTest(); &#125;&#125; 因此，也有些人认为Java的闭包不能算是真正意义上的闭包，有不可修改外部变量的限制。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"RESTful API开发的简单应用","slug":"RESTful API 开发","date":"2017-09-01T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/986c5bcd.html","link":"","permalink":"https://zguishen.com/posts/986c5bcd.html","excerpt":"在很早之前接触 Spring MVC 的时候，都知道 Spring MVC 支持 RESTful 风格API的开发，但对于 RESTful 只是有个模糊的认识，以至于甚至在开发写出来的接口其实不符合 RESTful 的要求。 定义REST 的全称是 Resource Representational State Transfer ，资源以某种表现形式进行状态转移Resource：资源，即数据；Representational：某种表现形式，比如用JSON，XML，JPEG等；State Transfer：状态变化。通过HTTP动词实现。","text":"在很早之前接触 Spring MVC 的时候，都知道 Spring MVC 支持 RESTful 风格API的开发，但对于 RESTful 只是有个模糊的认识，以至于甚至在开发写出来的接口其实不符合 RESTful 的要求。 定义REST 的全称是 Resource Representational State Transfer ，资源以某种表现形式进行状态转移Resource：资源，即数据；Representational：某种表现形式，比如用JSON，XML，JPEG等；State Transfer：状态变化。通过HTTP动词实现。HTTP动词有如下几个： GET 用来获取资源， POST 用来新建资源（也可以用于更新资源）， PUT 用来更新资源， DELETE 用来删除资源 在RESTful API中，URL中只使用名词来指定资源，原则上不使用动词，并且一般使用复数，比如 GET 操作 https://v1/users/1 来获取用户id为1的信息资源，禁止使用 http://v1/getUserById 、 http://v1/deleteUser 之类的url。 用处一种技术的存在肯定是为了解决一些问题而诞生的，REST是一种软件架构模式，通过使用RESTful 风格的 API 用来解决多端（PC、Android、IOS）共用一套统一的 API ，避免重复开发。 在 SpringMVC 中的应用用 SpringMVC 可以开发 restful 风格的restful api，以 Spring Boot 为基本框架，这里写一个基本的 controller 类1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping(\"/users\")public class UserController &#123; @Autowired UserService userService; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.GET) public String getUserById(@PathVariable(\"id\") String userId) &#123; return ResultUtil.success(userService.getUserById(userId), \"操作成功\"); &#125; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.PUT) public String updateUser(@PathVariable(\"id\") String userId) &#123; int num = userService.updateUser(userId); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125; @RequestMapping(method=RequestMethod.POST) public String insertUser(String userCode, String userName) &#123; int num = userService.insertUser(userCode, userName); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable(\"id\") String userId) &#123; int num = userService.deleteUser(userId); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125;&#125; ResultUtil 封装返回数据格式，这里只是一个简单的封装1234567891011121314151617181920212223242526272829303132333435363738public class ResultUtil &#123; private final static String SUCCESS = \"success\"; private final static String MSG = \"msg\"; private final static String DATA = \"data\"; public static String success(String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, true); result.put(MSG, msg); result.put(DATA, new Object()); return JSON.toJSONString(result); &#125; public static String success(Object data, String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, true); result.put(MSG, msg); result.put(DATA, data); return JSON.toJSONString(result); &#125; public static String error(String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, false); result.put(MSG, msg); result.put(DATA, new Object()); return JSON.toJSONString(result); &#125; public static String error(Object data, String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, false); result.put(MSG, msg); result.put(DATA, data); return JSON.toJSONString(result); &#125;&#125; 对应的请求url为：12查询、更新、删除： /users/1插入： /users 有时需要管理版本号会把版本号写在url，比如 v1/users/1、 v2/users/1 。至于请求是什么类型的，可以在请求在head中设置，如果是ajax请求则设置比较简单12345678910111213141516171819$.ajax(&#123; url: '/users/1', type: 'get',//put、delete success: function(data) &#123; console.log(data) &#125;&#125;);$.ajax(&#123; url: '/users', type: 'post', data: &#123; userCode: 'test', userName: '测试名字' &#125;, success: function(data) &#123; console.log(data) &#125;&#125;); RESTful API 的开发涉及许多细节和技术实现，实际开发中的应用会可能会用到一些封装库和框架，这里不做深入了解，只是简单的记录自己的一些基本认识，相关的知识参考了以下的链接。 #####相关参考链接 REST的出处论文 - 作者Roy Fielding RESTful API 设计指南 - 阮一峰的网络日志 怎样用通俗的语言解释REST，以及RESTful？ - 回答作者: 覃超","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Web技术","slug":"Web技术","permalink":"https://zguishen.com/tags/Web技术/"}]},{"title":"用本地服务器解决node-sass安装失败问题","slug":"用本地服务器解决node-sass安装失败问题","date":"2017-08-19T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/9b9878d.html","link":"","permalink":"https://zguishen.com/posts/9b9878d.html","excerpt":"今天要用到node-sass这东西，使用命令 npm install node-sass --save 安装。然而搞半天始终下载不来，换成淘宝的镜像都不行，因为下载时还会去github下载一个 win32-x64-48_binding.node 的包，然后下不来就一直卡着最后失败。","text":"今天要用到node-sass这东西，使用命令 npm install node-sass --save 安装。然而搞半天始终下载不来，换成淘宝的镜像都不行，因为下载时还会去github下载一个 win32-x64-48_binding.node 的包，然后下不来就一直卡着最后失败。一种解决方法就是根据下载失败提示的链接直接把那个二进制包下载下来，然后放在本地服务器目录下，比如可以根据失败提示的版本号在Nginx的html目录下以版本号建个文件夹放进去，像这样 nginx-1.10.1\\html\\v4.5.3\\win32-x64-48_binding.node ,然后执行 npm install node-sass --save-dev --sass-binary-site=http://localhost:8090/ --registry=https://registry.npm.taobao.org 端口号为Nginx设置的端口号， v4.5.3\\win32-x64-48_binding.node 这一串不用加，这样 win32-x64-48_binding.node 这个包就直接从本地服务器下载了。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"线程池","slug":"线程池","date":"2017-07-19T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/de7c53fe.html","link":"","permalink":"https://zguishen.com/posts/de7c53fe.html","excerpt":"创建一个新的线程是有代价的，创建大量的线程会消耗许多系统资源，影响系统的性能。这时，我们就需要使用线程池来管理线程，线程池能缓存线程，可用闲置的线程来执行新任务，能有效控制线程并发数，并对线程进行一些简单的管理。","text":"创建一个新的线程是有代价的，创建大量的线程会消耗许多系统资源，影响系统的性能。这时，我们就需要使用线程池来管理线程，线程池能缓存线程，可用闲置的线程来执行新任务，能有效控制线程并发数，并对线程进行一些简单的管理。 先创建一个线程任务类1234567891011121314151617public class TaskThread implements Runnable &#123; private static final Logger LOG = LoggerFactory.getLogger(TaskThread.class); private String task; public TaskThread(String task) &#123; this.task = task; &#125; @Override public void run() &#123; task(); &#125; private void task() &#123; LOG.info(\"任务:\" + task + \" 线程:\" + Thread.currentThread().getName()); &#125;&#125; 按照一般方式我们通过 new Thread(new TaskThread(&quot;task&quot;)); 的方式来创建一个线程，再调用start方法来启动线程。而线程池为我们提供了另一种创建管理方式，线程池的实现方式也有多种。 使用LinkedList做任务队列来实现一个简单线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.HashMap;import java.util.LinkedList;import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class WorkQueue&#123; private static final Logger LOG = LoggerFactory.getLogger(WorkQueue.class); private static Map&lt;String,WorkQueue&gt; queues = new HashMap&lt;String,WorkQueue&gt;(); private final int nThreads;//线程池大小 private final PoolWorker[] threads;//用数组实现线程池 private final LinkedList&lt;Runnable&gt; queue;//双向链表实现任务队列 /**私有构造**/ private WorkQueue(String name,int nThreads) &#123; this.nThreads = nThreads; queue = new LinkedList&lt;Runnable&gt;(); threads = new PoolWorker[nThreads]; for (int i=0; i&lt;this.nThreads; i++) &#123; threads[i] = new PoolWorker(name+\"_\"+(i+1)); threads[i].start(); &#125; LOG.info(\"初始化线程池，线程数：\"+nThreads); &#125; /**静态工厂方法创建线程池**/ public static WorkQueue createWorkQueue(String name,int count)&#123; WorkQueue wq = queues.get(name); if(wq == null)&#123; wq = new WorkQueue(name,count); queues.put(name, wq); &#125; return wq; &#125; /**执行任务**/ public void execute(Runnable r) &#123; synchronized(queue) &#123; queue.addLast(r); queue.notify(); &#125; &#125; /**工作线程类**/ private class PoolWorker extends Thread &#123; PoolWorker(String name)&#123; super(name); &#125; public void run() &#123; Runnable r; while (true) &#123; synchronized(queue) &#123; while (queue.isEmpty()) &#123; try&#123; queue.wait();//如果任务队列没有任务，等待 &#125;catch (InterruptedException ignored)&#123; &#125; &#125; r = (Runnable) queue.removeFirst();//有任务时，取出任务 &#125; try &#123; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 开始执行\"); r.run();//执行任务 &#125; catch (Exception e) &#123; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 执行出现异常！\"); e.printStackTrace(); &#125; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 执行完成\"); r = null; &#125; &#125; &#125;&#125; 测试例子，大小为10的线程池执行20个任务1234567WorkQueue wq = WorkQueue.createWorkQueue(\"thread\", 10);TaskThread task[] = new TaskThread[20];for(int i=0; i&lt; task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); wq.execute(task[i]);&#125; 使用Executors和ThreadPoolExecutor创建线程池Java 的 java.util.concurrent 包提供了 Executors 类来创建线程池，Executors 类有四种线程池构造，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 之前在阿里的开发手册中有看到，各种 Executors 返回的线程池对象弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 一般常用 newFixedThreadPool 构造返回 ExecutorService 对象来创建线程池。 ExecutorService 接口继承了 Executor 接口（Executor是接口，Executors是类），提供了线程池的操作的成员函数。 使用 Executors 创建线程池类1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool &#123; private static final Logger LOG = LoggerFactory.getLogger(ThreadPool.class); private static Map&lt;String,ThreadPool&gt; pools = new HashMap&lt;String,ThreadPool&gt;(); private int threadCount = 0; private String name = null;; ExecutorService service = null; private ThreadPool(String name,int count)&#123; this.threadCount = count; this.name = name; service = Executors.newFixedThreadPool(this.threadCount); LOG.info(\"初始化线程池，线程数[\"+this.name+\"]：\"+this.threadCount); &#125; public static ThreadPool createThreadPool(String name,int count)&#123; ThreadPool pool = pools.get(name); if(pool == null)&#123; pool = new ThreadPool(name,count); pools.put(name, pool); &#125; return pool; &#125; public void execute(Runnable r) &#123; service.execute(r); &#125; public void destroy() &#123; service.shutdown(); pools.remove(this.getName()); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 其中，看下 newFixedThreadPool 方法的源码12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 这是 ThreadPoolExecutor 类的一个实现，再看下构造方法的参数12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize 核心线程数。核心线程会一直存活，即使没有任务需要处理。即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。 maximumPoolSize 最大的线程数。当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maximumPoolSize。如果线程数已等于maximumPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。 keepAliveTime 存活时间。当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。 allowCoreThreadTimeout 属性标识默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。 测试例子123456ThreadPool threadPool = ThreadPool.createThreadPool(\"testThread\", 10);TaskThread task[] = new TaskThread[20];for(int i=0; i&lt; task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]);&#125; ThreadPoolExecutor 其他相关ThreadPoolExecutor 本身可以指定创建活跃线程数、限制线程池的大小，还可以创建自己的 RejectedExecutionHandler 来处理不适合放在工作队列里的任务。 终止策略 RejectedExecutionHandler 实现类,当提交的任务无法进入等待队列且线程池中创建的线程数量已经达到了最大线程数量的限制，则会拒绝新提交的任务123456789101112import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class RejectedExecutionHandlerImpl implements RejectedExecutionHandler &#123; private static final Logger LOG = LoggerFactory.getLogger(RejectedExecutionHandlerImpl.class); @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; LOG.info(r.toString() + \"不能执行。\"); &#125;&#125; 完整测试例子12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TaskTest &#123; private static final Logger LOG = LoggerFactory.getLogger(TaskTest.class); public static void main(String[] args) &#123; /*WorkQueue wq = WorkQueue.createWorkQueue(\"thread\", 10); TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); wq.execute(task[i]); &#125;*/ /*ThreadPool threadPool = ThreadPool.createThreadPool(\"testThread\", 10); TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]); &#125;*/ RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl(); ThreadFactory threadFactory = Executors.defaultThreadFactory(); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory, rejectionHandler); //TaskThread task[] = new TaskThread[4];//少数量任务 TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]); &#125; &#125;&#125; 线程池线程核心数设置为2，最大线程数设置为4，当执行少数量任务时线程池未饱和不会触发终止策略，而执行大量任务就可能会触发，比如以上测试例子的4个任务和20任务的区别。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"Spring Boot 打包部署","slug":"Spring Boot部署","date":"2017-07-14T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/22682308.html","link":"","permalink":"https://zguishen.com/posts/22682308.html","excerpt":"Spring Boot默认集成Web容器，部署也相对简单，如果需要以war包形式部署在外部Web容器上也可以，只需要做一些简单的修改配置。","text":"Spring Boot默认集成Web容器，部署也相对简单，如果需要以war包形式部署在外部Web容器上也可以，只需要做一些简单的修改配置。 使用集成的Web容器部署方式打包maven 工程在 eclipse 中执行 Run as Maven build，输入 clean package 进行打包，这里要注意的是 Spring Boot 打成jar包要可以运行，必须使用Spring Boot提供的一个插件，不然打成的普通的jar是无法运行Spring Boot工程的，一般会提示 jar中没有主清单属性。在pom.xml加入插件1234567891011&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 生成的 jar 包使用 java -jar xx.jar 命令就可以启动。 部署到外部Web容器方式在 pom.xml 文件将 &lt;packaging&gt;jar&lt;/packaging&gt; 改为 &lt;packaging&gt;war&lt;/packaging&gt;加上build插件，表明此Web工程不需要web.xml文件1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt;&lt;/plugin&gt; 排除 Spring Boot Tomcat 组件，scope 属性设为 provided12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在 Application 即main方法类同包下创建实现外部 Web 容器启动的启动类例子123456789import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;public class WxServletInitializer extends SpringBootServletInitializer&#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(WxApplication.class);//WxApplication 为原main函数启动类 &#125;&#125; 打包完毕将war包部署到外部Web容器。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"ThreadLcoal","slug":"ThreadLcoal","date":"2017-06-30T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/56d30272.html","link":"","permalink":"https://zguishen.com/posts/56d30272.html","excerpt":"ThreadLcoal不是线程，而是一个创建线程的局部变量的类，主要用于存储多线程下类的某些变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，当前线程的ThreadLocal的变量只能被该线程访问，而其他线程访问不到。","text":"ThreadLcoal不是线程，而是一个创建线程的局部变量的类，主要用于存储多线程下类的某些变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，当前线程的ThreadLocal的变量只能被该线程访问，而其他线程访问不到。使用类定义，支持泛型public class ThreadLocal&lt;T&gt;初始化值private T setInitialValue()set方法public void set(T value)get方法public T get() 例子12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test04 &#123; private ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;(); int i=0; class localTread implements Runnable&#123; public void setNum()&#123; local.set(i++); &#125; public Integer getNum()&#123; return local.get(); &#125; @Override public void run() &#123; if(local.get() == null)&#123; setNum(); System.out.println(\"set threadlocal num...\"); &#125; System.out.print(\"the object is: \"); System.out.println(local); System.out.println(local.get()); &#125; &#125; public static void main(String[] args) &#123; try &#123; localTread t = new Test04().new localTread(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); t1.start(); Thread.sleep(1000); t2.start(); Thread.sleep(1000); t3.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出123456789set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d0set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d1set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d2 可以看到三个线程访问的都是同一个ThreadLocal，但只能访问当前线程存储的各自的变量。看源码set方法的实现12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 通过获取当前线程，再ThreadL中，ThreadLocalMap用弱引用实现get方法实现12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 同样是为了解决多线程中变量冲突的问题，线程同步机制实现在某个时间点只有一个线程能访问变量，而ThreadLcoal是通过存储每个线程自己变量，以隔离多线程访问数据的冲突，一个损耗时间，一个损耗空间。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"泛型","slug":"泛型","date":"2017-06-29T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/7678a22a.html","link":"","permalink":"https://zguishen.com/posts/7678a22a.html","excerpt":"泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。使用泛型，意味着编写的代码可以被很多不同类型 的对象所重用。","text":"泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。使用泛型，意味着编写的代码可以被很多不同类型 的对象所重用。泛型类1234567891011121314151617181920212223public class ClassTest&lt;T&gt; &#123; public T firtsFiled; public T secondFiled; public void setFirtsFiled(T data)&#123; firtsFiled = data; &#125; public void setSecondFiled(T data)&#123; secondFiled = data; &#125; public T getFirtsFiled()&#123; return firtsFiled; &#125; public T getSecondFiled()&#123; return secondFiled; &#125; public static &lt;T&gt; T getStaticData(T data)&#123; return data; &#125;&#125; 以上是一个简单的泛型类，T成为类型变量，一般使用大写字母命名。在Java中常用变量E表示集合的元素类型，K和V表示关键字与值的类型，T表示任意类型（约定俗成的用法，事实随便一个字母都行）。当实例化泛型类型需要用具体类型替代类型变量例如：1234ClassTest&lt;String&gt; one = new ClassTest&lt;&gt;();ClassTest&lt;Integer&gt; two = new ClassTest&lt;&gt;();one.setFirtsFiled(\"data1\"); two.setFirtsFiled(123); 泛型方法泛型方法可以定义在普通类或泛型类中，与普通方法不同，泛型方法可以在调用它的时候定义类型变量。例如 public static &lt;T&gt; T getStaticData(T data) 就是一个泛型方法，在方法的返回值前加上 &lt;T&gt; ，在调用时指定类型变量，如下：12Integer staticData = ClassTest.getStaticData(9090);String hello = ClassTest.getStaticData(\"hello\"); 类型变量的限制先看这个代码123public static &lt;T extends Comparable&gt; boolean getMinData(T data)&#123; return data.compareTo(data) &gt; 0 ;&#125; 之所以在定义泛型方法时给 &lt;T&gt; 继承 Comparable 接口，是因为 data 的类型无法确定，不能保证对象都有 compareTo 方法。一个类型变量或通配符可以有多个限定，例如 T extends Comparable &amp; Serializable限定类型用“&amp;”分隔，而逗号用来分隔类型变量。在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。(core Java) 类型擦除在虚拟机中没有泛型类型对象，所有对象都属于普通类。Java中的泛型基本上都是在编译器这个级别实现的，生成的字节码信息中是不包含泛型中的类型信息的。在定义一个泛型类型时， 都会提供一个删去类型参数后的原始类型，擦除类型变量，并替换为限定类型（无限定的变量用Object）。例如以上的泛型类擦除类型后的原始类型：1234567891011121314151617181920212223public class ClassTest &#123; public Object firtsFiled; public Object secondFiled; public void setFirtsFiled(Object data)&#123; firtsFiled = data; &#125; public void setSecondFiled(Object data)&#123; secondFiled = data; &#125; public Object getFirtsFiled()&#123; return firtsFiled; &#125; public Object getSecondFiled()&#123; return secondFiled; &#125; public static Object getStaticData(Object data)&#123; return data; &#125;&#125; 所以，不能存在如此两个方法，编译器会提示错误123456public String getFirtsFiled(T a)&#123; return \"1\";&#125;public String getFirtsFiled(Object w)&#123; return \"1\";&#125; 通配符类型在泛型操作中进行参数传递时泛型类型必须匹配才能传递，使用通配符来设置传递参数的类型例子，其中Man是Peple的子类，不必关心实现：1234567891011121314151617181920public class SubClass &#123; public void test(ClassTest&lt;Peple&gt; p)&#123; &#125; public void transfer(ClassTest&lt;? extends Peple&gt; p )&#123; &#125; public static void main(String[] args) &#123; SubClass sub = new SubClass(); ClassTest&lt;Man&gt; tt = new ClassTest&lt;&gt;(); //sub.test(tt);错误 sub.transfer(tt); ClassTest&lt;? extends Peple&gt; tt2 = new ClassTest(); //tt2.setFirtsFiled(new Man());错误 //tt2.setFirtsFiled(new Peple());错误 Peple pp =tt2.getSecondFiled(); &#125;&#125; 当调用 sub.test(tt); 时发生错误，我们不能把一个 ClassTest&lt;Man&gt; 传递给这个方法， tt 的类型是 ClassTest&lt;People&gt; ，但定义 public void transfer(ClassTest&lt;? extends Peple&gt; p ) 使用通配符后 sub.transfer(tt); 可以正确使用。再看下面的两个错误，使用通配符后set方法和get方法显然为12void setFirtsFiled(? extends Peple)? extends Peple getSecondFiled() 编译器只知道要将 People 的子类型，但未具体指定，所有set方法会报错，而get方法就没这个问题，有点类似于多态的子类对象指定父类引用，返回一个 People 子类型没有问题。 通配符的超类限定有 extends 来匹配子类，当然也有 super 来指定超类型限定，使用的意思刚好相反123456789101112131415161718192021public class SubClass &#123; public void test(ClassTest&lt;Man&gt; m)&#123; &#125; public void transfer(ClassTest&lt;? super Man&gt; m )&#123; &#125; public static void main(String[] args) &#123; SubClass sub = new SubClass(); ClassTest&lt;Peple&gt; tt = new ClassTest&lt;&gt;(); //sub.test(tt);错误 sub.transfer(tt); ClassTest&lt;? super Man&gt; tt2 = new ClassTest(); tt2.setFirtsFiled(new Tom());//Tom继承自Man tt2.setFirtsFiled(new Man()); //tt2.setFirtsFiled(new Peple());错误 //Peple pp = tt2.getSecondFiled();错误 &#125;&#125; transfer 方法允许使用通配符方式传进一个 ClassTest&lt;Peple&gt; ,因为 People 是 Man 的超类。下面的两个错误是因为此时不确定get方法返回的对象类型无法保证，只能把它赋给一个 Object ，而set方法可以使用任意 Man 对象或它的子类型调用它。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"SSM框架，基于JavaConfig配置方式，不用xml配置文件","slug":"SSM框架，基于JavaConfig配置方式，不用xml配置文件","date":"2017-06-13T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/79ede04d.html","link":"","permalink":"https://zguishen.com/posts/79ede04d.html","excerpt":"在使用Spring开发时，我们经常会看到各种各样xml配置，过于繁多的xml配置显得复杂烦人。在Spring3之后，Spring支持使用JavaConfig来代替xml配置，这种方式也得到越来越多人的推荐，甚至在Spring Boot的项目中，基本上已经见不到xml的影子了。这里将使用JavaConfig方式对SSM框架进行整合。","text":"在使用Spring开发时，我们经常会看到各种各样xml配置，过于繁多的xml配置显得复杂烦人。在Spring3之后，Spring支持使用JavaConfig来代替xml配置，这种方式也得到越来越多人的推荐，甚至在Spring Boot的项目中，基本上已经见不到xml的影子了。这里将使用JavaConfig方式对SSM框架进行整合。一、maven 的pom.xml配置各种jar包的配置如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.open.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;mysql-connector-java.version&gt;5.1.37&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.3&lt;/fastjson.version&gt; &lt;slf4j.version&gt;1.7.12&lt;/slf4j.version&gt; &lt;commons-io.version&gt;2.4&lt;/commons-io.version&gt; &lt;commons-fileupload.version&gt;1.3.2&lt;/commons-fileupload.version&gt; &lt;commons-collections.version&gt;3.2.2&lt;/commons-collections.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt; &lt;javax.servlet-api.version&gt;3.1.0&lt;/javax.servlet-api.version&gt; &lt;druid.version&gt;1.0.16&lt;/druid.version&gt; &lt;mybatis.version&gt;3.4.0&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;1.3.0&lt;/mybatis-spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--common 组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-collections.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;!-- javax.servlet相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8088&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 二、SpringMvc的配置首先创建一个初始化类，继承 AbstractAnnotationConfigDispatcherServletInitializer 1234567891011121314151617181920212223242526272829303132package com.open.ssm.config;import org.apache.log4j.Logger;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;/** *&lt;p&gt;Title: SpittrWebAppInitializer.java&lt;/p&gt; *&lt;p&gt;Description: 前端控制器配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; private final static Logger LOG = Logger.getLogger(WebAppInitializer.class); @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; LOG.info(\"------root配置类初始化------\"); return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; LOG.info(\"------web配置类初始化------\"); return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; @Override protected String[] getServletMappings() &#123; LOG.info(\"------映射根路径初始化------\"); return new String[]&#123; \"/\" &#125;;//请求路径映射，根路径 &#125;&#125; 这里需要实现三个方法，可以其中两个方法看到需要两个配置类 RootConfig 和 WebConfig , getServletMappings 方法处理路径映射到 “/”，表示默认的Servlet，会处理进入应用的所有请求。 其中 WebConfig 用于定义 DispatcherServlet 加载应用上下文的配置，主要包含一些web组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.open.ssm.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;/** *&lt;p&gt;Title: WebConfig.java&lt;/p&gt; *&lt;p&gt;Description: 配置类，用于定义DispatcherServlet上下文的bean&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@EnableWebMvc@ComponentScan( \"com.open.ssm.controller\" )public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/view/\"); resolver.setSuffix(\".jsp\"); return resolver; &#125; //文件上传，bean必须写name属性且必须为multipartResolver，不然取不到文件对象，别问我为什么，我也唔知 @Bean(name=\"multipartResolver\") protected CommonsMultipartResolver MultipartResolver() &#123; CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); //multipartResolver.setUploadTempDir(new FileSystemResource(\"/tmp\"));//可不设置 multipartResolver.setMaxUploadSize(2097152);//2M multipartResolver.setMaxInMemorySize(0); multipartResolver.setDefaultEncoding(\"UTF-8\"); return multipartResolver; &#125; //静态资源的处理 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 而 RootConfig 类主要配置持久层的一些东西，包括数据库、Mybatis框架，事务之类的东西。12345678910111213141516171819202122232425262728package com.open.ssm.config;import org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** *&lt;p&gt;Title: RootConfig.java&lt;/p&gt; *&lt;p&gt;Description: 配置类，用于管理ContextLoadListener创建的上下文的bean&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@ComponentScan(basePackages=&#123; \"com.open.ssm.config\", \"com.open.ssm.dao\", \"com.open.ssm.service\" &#125;)@Import(DruidDataSourceConfig.class)public class RootConfig &#123; @Bean public BeanNameAutoProxyCreator proxycreate()&#123; BeanNameAutoProxyCreator proxycreate = new BeanNameAutoProxyCreator(); proxycreate.setProxyTargetClass(true); proxycreate.setBeanNames(\"*ServiceImpl\"); proxycreate.setInterceptorNames(\"transactionInterceptor\"); return proxycreate; &#125; &#125; 三、数据库与Mybatis相关配置这里的数据源使用的是阿里的Druid，接上面 RootConfig 类，可以看到 RootConfig 类又 import 导入了一个配置类 DruidDataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package com.open.ssm.config;import java.io.IOException;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.log4j.Logger;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.interceptor.TransactionInterceptor;import com.alibaba.druid.pool.DruidDataSource;/** *&lt;p&gt;Title: DruidDataSourceConfig.java&lt;/p&gt; *&lt;p&gt;Description: 数据源属性配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@PropertySource(\"classpath:/jdbc.properties\")@MapperScan(basePackages=\"com.open.ssm.dao\")public class DruidDataSourceConfig&#123; private final static Logger LOG = Logger.getLogger(DruidDataSourceConfig.class); @Value(\"$&#123;spring.datasource.url&#125;\") private String dbUrl; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; @Value(\"$&#123;spring.datasource.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;spring.datasource.initialSize&#125;\") private int initialSize; @Value(\"$&#123;spring.datasource.minIdle&#125;\") private int minIdle; @Value(\"$&#123;spring.datasource.maxActive&#125;\") private int maxActive; @Value(\"$&#123;spring.datasource.maxWait&#125;\") private int maxWait; @Value(\"$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;\") private int timeBetweenEvictionRunsMillis; @Value(\"$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;\") private int minEvictableIdleTimeMillis; @Value(\"$&#123;spring.datasource.validationQuery&#125;\") private String validationQuery; @Value(\"$&#123;spring.datasource.testWhileIdle&#125;\") private boolean testWhileIdle; @Value(\"$&#123;spring.datasource.testOnBorrow&#125;\") private boolean testOnBorrow; @Value(\"$&#123;spring.datasource.testOnReturn&#125;\") private boolean testOnReturn; @Value(\"$&#123;spring.datasource.poolPreparedStatements&#125;\") private boolean poolPreparedStatements; @Value(\"$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"$&#123;spring.datasource.filters&#125;\") private String filters; @Value(\"&#123;spring.datasource.connectionProperties&#125;\") private String connectionProperties; @Bean //声明其为Bean实例 public DataSource dataSource()&#123; LOG.info(\"Initialize the data source...\"); DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(this.dbUrl); datasource.setUsername(username); datasource.setPassword(password); datasource.setDriverClassName(driverClassName); //configuration datasource.setInitialSize(initialSize); datasource.setMinIdle(minIdle); datasource.setMaxActive(maxActive); datasource.setMaxWait(maxWait); datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); datasource.setValidationQuery(validationQuery); datasource.setTestWhileIdle(testWhileIdle); datasource.setTestOnBorrow(testOnBorrow); datasource.setTestOnReturn(testOnReturn); datasource.setPoolPreparedStatements(poolPreparedStatements); datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try &#123; datasource.setFilters(filters); &#125; catch (SQLException e) &#123; LOG.error(\"druid configuration initialization filter\", e); &#125; datasource.setConnectionProperties(connectionProperties); return datasource; &#125; /* //JdbcTemplate的配置 @Bean public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource()); return jdbcTemplate; &#125; @Bean public NamedParameterJdbcTemplate namedParameterJdbcTemplate()&#123; NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource()); return namedParameterJdbcTemplate; &#125;*/ //mybatis的配置 @Bean public SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException&#123; ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(); SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource()); sqlSessionFactoryBean.setMapperLocations(resourcePatternResolver.getResources(\"classpath*:mappers/*.xml\")); sqlSessionFactoryBean.setTypeAliasesPackage(\"com.open.ssm.model\");//别名，让*Mpper.xml实体类映射可以不加上具体包名 return sqlSessionFactoryBean; &#125; @Bean(name = \"transactionManager\") public DataSourceTransactionManager dataSourceTransactionManager()&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource()); return dataSourceTransactionManager; &#125; @Bean(name=\"transactionInterceptor\") public TransactionInterceptor interceptor()&#123; TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionManager(dataSourceTransactionManager()); Properties transactionAttributes = new Properties(); transactionAttributes.setProperty(\"save*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"del*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"update*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"get*\", \"PROPAGATION_REQUIRED,readOnly\"); transactionAttributes.setProperty(\"find*\", \"PROPAGATION_REQUIRED,readOnly\"); transactionAttributes.setProperty(\"*\", \"PROPAGATION_REQUIRED\"); interceptor.setTransactionAttributes(transactionAttributes); return interceptor; &#125; /* //放这里会导致@value注解获取不到配置的值，移到RootConfig @Bean public BeanNameAutoProxyCreator proxycreate()&#123; BeanNameAutoProxyCreator proxycreate = new BeanNameAutoProxyCreator(); proxycreate.setProxyTargetClass(true); proxycreate.setBeanNames(\"*ServiceImpl\"); proxycreate.setInterceptorNames(\"transactionInterceptor\"); return proxycreate; &#125;*/ &#125; 数据库连接信息文件 jdbc.properties 相关内容12345678910111213141516171819202122232425262728spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/blogspring.datasource.username=rootspring.datasource.password=root#连接池配置spring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20#连接等待超时时间spring.datasource.maxWait=60000#配置隔多久进行一次检测(检测可以关闭的空闲连接)spring.datasource.timeBetweenEvictionRunsMillis=60000#配置连接在池中的最小生存时间spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.filters=stat,wall,log4j# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 这里数据库的事务配置方式有三种： 第一种最简单的方式，在 RootConfig 加上 @EnableTransactionManagement 注解，再加上配置 DataSourceTransactionManager 的bean，就可以在service实现层使用 @Transactional 注解为方法手动加上事务，并且指定的传播属性等等，但老是要手动加 @Transactional 注解实在麻烦 第二种就是文中使用的方式，使用 BeanNameAutoProxyCreator 拦截代理方式，先创建一个 TransactionInterceptor bean，配置好事务传播等属性，在由 BeanNameAutoProxyCreator 进行事务代理。这里有个问题就是 BeanNameAutoProxyCreator 放在 RootConfig 中居然会导致 @value注解获取不到配置文件的值，而是键名字，将它直接放到 RootConfig 下就没事了 第三种是采用aop切面事务， @EnableAspectJAutoProxy 开启切面自动代理，这里写一个切面相关类 AspectConfig ，然后在 使用 @Import(AspectConfig.class) 导进配置就行，由于 &lt;tx: 开头的这种标签实在不知如何用java方式表示，在 stackoverflow 看到一个答案讲还是只能写一个xml文件，使用 @ImportResource(“classpath:/aop-config.xml”) 这种方式进行配置，具体实现如下(三种方式根据需要去掉无关代码，免得出冲突) 1234567891011121314151617181920212223package com.open.ssm.config;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.context.annotation.ImportResource;import org.springframework.stereotype.Component;/** *&lt;p&gt;Title: AspectConfig.java&lt;/p&gt; *&lt;p&gt;Description: 切面事务&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Aspect@Component@ImportResource(\"classpath:/aop-config.xml\")public class AspectConfig &#123; @Pointcut(\"execution(* com.open.ssm.service.*.*(..))\") public void serviceAnnotatedClass() &#123; &#125; &#125; 四、Druid监控Druid监控这里使用最简单的方式，就一个servlet和一个filterservlet 继承自 StatViewServlet123456789101112131415161718192021222324package com.open.ssm.web;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import com.alibaba.druid.support.http.StatViewServlet;/** *&lt;p&gt;Title: DruidServlMonitor.java&lt;/p&gt; *&lt;p&gt;Description: Druid Servlet&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月14日&lt;/p&gt; *@author shen *@version v1.0 */@WebServlet(name=\"druidMonitor\", urlPatterns=\"/druid/*\", initParams=&#123; @WebInitParam(name=\"allow\", value=\"127.0.0.1\"), @WebInitParam(name=\"loginUsername\", value=\"admin\"), @WebInitParam(name=\"loginPassword\", value=\"123123\"), @WebInitParam(name=\"resetEnable\", value=\"false\")&#125;)public class DruidServletMonitor extends StatViewServlet&#123; /** * */ private static final long serialVersionUID = 1L;&#125; filter继承自 WebStatFilter123456789101112131415package com.open.ssm.web;import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;import com.alibaba.druid.support.http.WebStatFilter;/** * Servlet Filter implementation class DruidStatFilter */@WebFilter(filterName=\"druidFilter\", urlPatterns=\"/*\", initParams=&#123; @WebInitParam(name=\"exclusions\", value=\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\")&#125;)public class DruidStatFilter extends WebStatFilter &#123;&#125; 浏览器直接输入ip+端口/druid，这里在本地是 http://localhost:8088/druid 进入登录页面，输入配置的用户名密码就可以进入监控页面了。 本文我写了一个demo，放在 https://github.com/zgshen/ssm-demo ，后续有时间会加上其他的一些东西。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"Spring Boot 普通类调用Bean对象的一种方式","slug":"Spring Boot 普通类调用Bean对象的一种方式","date":"2017-06-07T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/64ebe403.html","link":"","permalink":"https://zguishen.com/posts/64ebe403.html","excerpt":"有时我们有一些特殊的需要，可能要在一个不被Spring管理的普通类中去调用Spring管理的bean对象的一些方法，比如一般SpringMVC工程在controller中通过12@Autowiredprivate TestService testService; 注入TestService 接口就可以调用此接口实现类的实现的方法。","text":"有时我们有一些特殊的需要，可能要在一个不被Spring管理的普通类中去调用Spring管理的bean对象的一些方法，比如一般SpringMVC工程在controller中通过12@Autowiredprivate TestService testService; 注入TestService 接口就可以调用此接口实现类的实现的方法。但在一般类中显然不可以这么做，注入的 TestService 将会报空指针异常，你无法拿到这个bean，在一般的ssm工程中我们可以通过xml配置把普通类设置成一个bean对象，那么 TestService 就有效了， 或者使用 ApplicationContext 直接读取xml配置中的bean也可以拿到 TestService。` Spring Boot 已经摒弃了各种繁琐的xml配置，当然就不再使用xml配置的方式，之前在网上看到一种很简便的方式，但现在又找不到链接了，这里做下记录。 在普通类中定义 ApplicationContext 静态变量和set方法12345private static ApplicationContext applicationContext;//启动类set入，调用下面set方法public static void setApplicationContext(ApplicationContext context) &#123; applicationContext = context;&#125; 在启动类中，启动时事实已经生成 ConfigurableApplicationContext 对象， ConfigurableApplicationContext 是 ApplicationContext 接口的实现，这里直接传到普通类的 setApplicationContext 方法就行了123456789@SpringBootApplication@ServletComponentScanpublic class WxApplication implements EmbeddedServletContainerCustomizer&#123; public static void main(String[] args) &#123; ConfigurableApplicationContext applicationContext = SpringApplication.run(WxApplication.class, args); TestClass.setApplicationContext(applicationContext); &#125;&#125; 由于是静态变量，类加载时 applicationContext 已经存在，就可获取到 TestService 了，唯一不好就是静态变量在服务器启动后将一直存在12345678910111213public class TestClass &#123; private static ApplicationContext applicationContext;//启动类set入，调用下面set方法 public static void setApplicationContext(ApplicationContext context) &#123; // TODO Auto-generated method stub applicationContext = context; &#125; public void getBeanTest()&#123; TestService testService = (TestService)applicationContext.getBean(TestService.class); &#125;&#125; 补充：在普通 Spring 工程在启动的时候都会通过 org.springframework.web.context.ContextLoaderListener 监听器从加载系统资源并管理bean， Spring 提供的 WebApplicationContextUtils 工具类能在请求时获取到运行时工程的bean，如果看源码就可以知道监听器执行时与 WebApplicationContextUtils 类的关联 12345678910//封装一下，类的class和请求request为必要参数public static &lt;T&gt; T getBean(Class&lt;? extends Object&gt; cla,HttpServletRequest request)&#123; if(request == null)&#123; return null; &#125; return (T)WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext()).getBean(cla);//getBean参数可为bean类的.class或直接是bean的Id &#125;//这样获取beanTestService testService= (TestService)getBean(TestService.class, request);","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zguishen.com/tags/Spring/"}]},{"title":"Spring Boot 过滤器、监听器和拦截器使用","slug":"Spring Boot 过滤器、监听器和拦截器使用","date":"2017-06-06T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/229b061d.html","link":"","permalink":"https://zguishen.com/posts/229b061d.html","excerpt":"1、过滤器和监听器Spring Boot中对于过滤器和监听器的使用跟一般web工程中使用方式没什么不同，使用注解方式就可以快速创建，只是要使用注解方式需要在Application类加上 @ServletComponentScan 注解表明开启servlet的注解创建一个监听器","text":"1、过滤器和监听器Spring Boot中对于过滤器和监听器的使用跟一般web工程中使用方式没什么不同，使用注解方式就可以快速创建，只是要使用注解方式需要在Application类加上 @ServletComponentScan 注解表明开启servlet的注解创建一个监听器12345678910111213141516@WebListenerpublic class FirstListener implements ServletContextListener&#123; private static Logger LOG = LoggerFactory.getLogger(FirstListener.class); @Override public void contextInitialized(ServletContextEvent sce) &#123; LOG.info(\"FirstListener 初始化...\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; LOG.info(\"FirstListener 销毁...\"); &#125;&#125; 创建一个过滤器，过滤test和hello下文的所有路径1234567891011121314151617181920212223242526@WebFilter(filterName=\"firstFilter\", urlPatterns = &#123; \"/test/*\", \"/hello/*\" &#125;)public class FirsrtFilter implements Filter&#123; private static Logger LOG = LoggerFactory.getLogger(FirsrtFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String requestURI = req.getRequestURI(); LOG.info(\"过滤到的请求---&gt;\"+requestURI); &#125; @Override public void destroy() &#123; &#125;&#125; 运行 application 类可看到日志输出2017-06-08 17:14:55.252 INFO 7552 --- [ost-startStop-1] com.fyft.test.web.FirstListener : FirstListener 初始化... 写一个请求路径为 test 的 controller 并访问，可看到2017-06-08 17:15:50.799 INFO 7552 --- [nio-8003-exec-1] com.fyft.test.web.FirsrtFilter : 过滤到的请求---&gt;/test 2、拦截器 实现 HandlerInterceptor 接口创建一个拦截器类123456789101112131415161718192021222324public class MyInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行，主要是用于进行资源清理工作 &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub //请求处理之后进行调用，但是在视图被渲染之前，即Controller方法调用之后 &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object object) throws Exception &#123; // TODO Auto-generated method stub //controller方法调用之前 return true; &#125;&#125; 然后在初始化配置类中注册拦截器1234567891011121314@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter &#123; /** * 添加拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/*\"); //registry.addInterceptor(new MyInterceptor_copy()).addPathPatterns(\"/*\");//有多个拦截器继续add进去 super.addInterceptors(registry); &#125;&#125; 这里的拦截器只有经过DispatcherServlet 的请求，才会走拦截器链，默认不拦截静态资源，Spring Boot中默认的静态资源路径有 classpath:/META-INF/resources/，classpath:/resources/，classpath:/static/，classpath:/public/ ，在拦截器中我们可以处理一些我们需要的业务，比如防xss攻击，在调用controller前对提交内容进行过滤等等。 参考博客 http://blog.csdn.net/catoop/article/details/50501696","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"深圳","slug":"深圳","date":"2017-05-27T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/564391ac.html","link":"","permalink":"https://zguishen.com/posts/564391ac.html","excerpt":"","text":"深圳北站。","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"Spring Boor配置Druid数据源","slug":"Spring Boor配置Druid数据源","date":"2017-05-17T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/bd1de05c.html","link":"","permalink":"https://zguishen.com/posts/bd1de05c.html","excerpt":"Druid是阿里巴巴开源平台上的一个项目,整个项目由数据库连接池、插件框架和SQL解析器组成。 添加Druid数据源要使用Druid数据源，我们需要在 application.properties 下添加配置信息","text":"Druid是阿里巴巴开源平台上的一个项目,整个项目由数据库连接池、插件框架和SQL解析器组成。 添加Druid数据源要使用Druid数据源，我们需要在 application.properties 下添加配置信息1234567891011121314151617181920212223242526272829303132#数据库访问配置#mysql#spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#spring.datasource.driver-class-name=com.mysql.jdbc.Driver#spring.datasource.url=jdbc:mysql://localhost:3306/blog#oraclespring.datasource.driverClassName=oracle.jdbc.driver.OracleDriverspring.datasource.url=jdbc:oracle:thin:@127.0.0.1:1521:orclspring.datasource.username=systemspring.datasource.password=123456#连接池配置spring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20#连接等待超时时间spring.datasource.maxWait=60000#配置隔多久进行一次检测(检测可以关闭的空闲连接)spring.datasource.timeBetweenEvictionRunsMillis=60000#配置连接在池中的最小生存时间spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.filters=stat,wall,log4j# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 上面提供了mysql和oracle两种数据库驱动的配置，由于maven中心仓库不提供oracle驱动，需要到oracle官网自行下载你自己版本需要的oracle数据库驱动，再安装到本地仓库。我这里用的eclipse自带的maven，安装oracle数据库驱动到本地仓库是直接建个文件夹丢进去重命下名的，简单粗暴。 参考：jar包放com/oracle/ojdbc6/10.2.0.1.0 文件夹下，命名ojdbc6-10.2.0.1.0.jar12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;$&#123;ojdbc6.version&#125;&lt;/version&gt;&lt;/dependency&gt; 此外，在本版本（1.5.2）的Spring Boot 中，对于上面Druid连接池的配置都不支持，意味着这些配置属性不会生效，所以，需要些一个配置类来读取这些配置并设置到数据源中去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.fyft.wx.config;import java.sql.SQLException;import javax.sql.DataSource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import com.alibaba.druid.pool.DruidDataSource;/** *&lt;p&gt;Title: DruidDataSourceConfig.java&lt;/p&gt; *&lt;p&gt;Description: 数据源属性配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月18日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@Primary //在同样的DataSource中，首先使用被标注的DataSourcepublic class DruidDataSourceConfig extends DataSourceProperties&#123; private Logger logger = LoggerFactory.getLogger(DruidDataSourceConfig.class); @Value(\"$&#123;spring.datasource.url&#125;\") private String dbUrl; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; @Value(\"$&#123;spring.datasource.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;spring.datasource.initialSize&#125;\") private int initialSize; @Value(\"$&#123;spring.datasource.minIdle&#125;\") private int minIdle; @Value(\"$&#123;spring.datasource.maxActive&#125;\") private int maxActive; @Value(\"$&#123;spring.datasource.maxWait&#125;\") private int maxWait; @Value(\"$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;\") private int timeBetweenEvictionRunsMillis; @Value(\"$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;\") private int minEvictableIdleTimeMillis; @Value(\"$&#123;spring.datasource.validationQuery&#125;\") private String validationQuery; @Value(\"$&#123;spring.datasource.testWhileIdle&#125;\") private boolean testWhileIdle; @Value(\"$&#123;spring.datasource.testOnBorrow&#125;\") private boolean testOnBorrow; @Value(\"$&#123;spring.datasource.testOnReturn&#125;\") private boolean testOnReturn; @Value(\"$&#123;spring.datasource.poolPreparedStatements&#125;\") private boolean poolPreparedStatements; @Value(\"$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"$&#123;spring.datasource.filters&#125;\") private String filters; @Value(\"&#123;spring.datasource.connectionProperties&#125;\") private String connectionProperties; @Bean //声明其为Bean实例 public DataSource dataSource()&#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(this.dbUrl); datasource.setUsername(username); datasource.setPassword(password); datasource.setDriverClassName(driverClassName); //configuration datasource.setInitialSize(initialSize); datasource.setMinIdle(minIdle); datasource.setMaxActive(maxActive); datasource.setMaxWait(maxWait); datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); datasource.setValidationQuery(validationQuery); datasource.setTestWhileIdle(testWhileIdle); datasource.setTestOnBorrow(testOnBorrow); datasource.setTestOnReturn(testOnReturn); datasource.setPoolPreparedStatements(poolPreparedStatements); datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try &#123; datasource.setFilters(filters); &#125; catch (SQLException e) &#123; logger.error(\"druid configuration initialization filter\", e); &#125; datasource.setConnectionProperties(connectionProperties); return datasource; &#125;&#125; 本段配置参考自 http://blog.csdn.net/blueheart20/article/details/52384032其中 @Primary 注解需要放在类上，不然本类配置还是不会覆盖默认的数据源配置，原作者是放在 public DataSource dataSource() 方法上，会报存在两个配置的错误，估计是Spring Boot版本的差异问题。 配置监控统计功能新建一个配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.fyft.wx.config;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;/** *&lt;p&gt;Title: DruidConfiguration.java&lt;/p&gt; *&lt;p&gt;Description: Druid监控配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月3日&lt;/p&gt; *@author shen *@version v1.0 */@Configurationpublic class DruidMonitorConfig &#123; /** * 注册ServletRegistrationBean * @return */ @Bean public ServletRegistrationBean registrationBean() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); /** 初始化参数配置，initParams**/ //白名单 bean.addInitParameter(\"allow\", \"127.0.0.1\");//多个ip逗号隔开 //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page. //bean.addInitParameter(\"deny\", \"192.168.1.73\"); //登录查看信息的账号密码. bean.addInitParameter(\"loginUsername\", \"admin\"); bean.addInitParameter(\"loginPassword\", \"123456\"); //是否能够重置数据. bean.addInitParameter(\"resetEnable\", \"false\"); return bean; &#125; /** * 注册FilterRegistrationBean * @return */ @Bean public FilterRegistrationBean druidStatFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(new WebStatFilter()); //添加过滤规则. bean.addUrlPatterns(\"/*\"); //添加不需要忽略的格式信息. bean.addInitParameter(\"exclusions\",\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"); return bean; &#125; &#125; 启动项目后访问 ip:端口/druid 输入配置类设置的账号密码进入监控后台。我们先执行一个数据库操作，可以在sql监控选项卡看到执行的sql 查看数据源选项卡可以看到配置连接池参数也都生效了","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"Spring Boot 热部署与日志配置","slug":"Spring Boot 热部署与日志配置","date":"2017-05-10T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/7d32a007.html","link":"","permalink":"https://zguishen.com/posts/7d32a007.html","excerpt":"热部署和日志是开发中常用的功能，Srping Boot同样集成了相应的工具，可以方便地实现这些功能。 热部署Spring Boot提供了 spring-boot-devtools 模块用于热部署，直接引入就行。","text":"热部署和日志是开发中常用的功能，Srping Boot同样集成了相应的工具，可以方便地实现这些功能。 热部署Spring Boot提供了 spring-boot-devtools 模块用于热部署，直接引入就行。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 当修改代码重新编译时，工程就会重新启动加载。 日志功能当引入 spring-boot-starter-web 时候，Spring Boot已经自动引入 spring-boot-starter-logging ，这里我们使用Logback来实现日志管理。Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 在spring-boot-starter-xx.RELEASE.jar （xx为版本号）下 org.springframework.boot.logging.logback 包中可看到一个base.xml文件,这是Spring Boot 的logback的默认配置。内容12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--Base logback configuration provided for compatibility with Spring Boot 1.1--&gt;&lt;included&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\" /&gt; &lt;property name=\"LOG_FILE\" value=\"$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;\"/&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\" /&gt; &lt;include resource=\"org/springframework/boot/logging/logback/file-appender.xml\" /&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/included&gt; 可以看到日志的输出级别是INFO，输出到文件需要我们东东配置下路径。在application.properties进行配置如下123#日志配置logging.file=test.loglogging.level.com.fyft.wx.controller=warn 运行会在工程根目录看到生成的日志文件，把com.fyft.wx.controller 包的日志级别设置为warn了controller下写个测试类123456789101112131415161718package com.fyft.wx.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class IndexController &#123; private final static Logger LOG = LoggerFactory.getLogger(IndexController.class); @RequestMapping(\"test\") public String name() &#123; LOG.info(\"a info logger...\"); LOG.error(\"a error logger...\"); return \"welcome to the FYFT index page.I'm shen.\"; &#125;&#125; 访问本controller，输出（日志级别ALL &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF，所以只输出error的） 如果我们需要更复杂的日志功能，可以自己写一个xml文件来配置，比如输出到控制台使用Spring Boot的默认配置，而输出到文件使用自定义配置。在resources下新建一个logback.xml配置文件并把刚才logging.file的配置删掉，配置如下12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 继承默认配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;logger name=\"org.springframework.web\" level=\"WARN\"/&gt; &lt;!-- 日志存储路径 --&gt; &lt;property name=\"LOG_HOME\" value=\"D:\\\\logs\" /&gt; &lt;!-- 文件输出配置 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;File&gt;$&#123;LOG_HOME&#125;\\\\fyft-wx.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover 保存历史记录到这个文件夹一日起为后缀 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;\\\\temp\\\\fyft-wx.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- keep 30 days' worth of history 保存天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 日志大小 --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;2MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root节点，配置日志级别，添加输出节点 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"FILE\"&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; 如果输出到控制台的日志也需要自定义，就再加上一个 appender 配置，并添加到root节点。需要注意的是继承自 Spring Bootd 配置需要去掉，不然控制台的日志会输出两次（logger输出一次，root输出一次） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 去掉继承的配置 --&gt; &lt;!-- &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;logger name=\"org.springframework.web\" level=\"WARN\"/&gt; --&gt; &lt;!-- 日志存储路径 --&gt; &lt;property name=\"LOG_HOME\" value=\"D:\\\\logs\" /&gt; &lt;!-- 文件输出配置 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;File&gt;$&#123;LOG_HOME&#125;\\\\fyft-wx.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover 保存历史记录到这个文件夹一日起为后缀 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;\\\\temp\\\\fyft-wx.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- keep 30 days' worth of history 保存天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 日志大小 --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;2MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出配置 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，$&#123;PID&#125; 进程Id， %thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;PID&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root节点，配置日志级别，添加输出节点 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"FILE\"&gt;&lt;/appender-ref&gt; &lt;appender-ref ref=\"STDOUT\"&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; 其他更多详细的logback配置可查看官方文档 https://logback.qos.ch/manual/configuration.html","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"创建一个Spring Boot工程","slug":"创建Spring Boot工程","date":"2017-05-09T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/bd996c24.html","link":"","permalink":"https://zguishen.com/posts/bd996c24.html","excerpt":"在搭建传统的SpringMVC项目或其他Spring项目的的时候，我们通常都需要写一堆与Spring整合的xml配置文件，过程繁琐复杂不说，而且容易出错。为了简化开发，Spring Boot应运而生。Spring Boot可以创建独立运行的基于Spring的应用，并且大多数时候只需编写少量的配置。能独立运行的原因是Spring Boot项目本身嵌入了Tomcat等其他web容器插件，详细介绍看官网http://projects.spring.io/spring-boot/。 创建一个Spring Boot 项目1、pom.xml配置(1)基本配置这里使用Maven构建工程，根据官网的推荐，项目可继承于spring-boot-starter-parent 来管理工程。","text":"在搭建传统的SpringMVC项目或其他Spring项目的的时候，我们通常都需要写一堆与Spring整合的xml配置文件，过程繁琐复杂不说，而且容易出错。为了简化开发，Spring Boot应运而生。Spring Boot可以创建独立运行的基于Spring的应用，并且大多数时候只需编写少量的配置。能独立运行的原因是Spring Boot项目本身嵌入了Tomcat等其他web容器插件，详细介绍看官网http://projects.spring.io/spring-boot/。 创建一个Spring Boot 项目1、pom.xml配置(1)基本配置这里使用Maven构建工程，根据官网的推荐，项目可继承于spring-boot-starter-parent 来管理工程。 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (2)如果不使用官方依赖实际开发中我们可能想自己创建父工程来管理依赖，例如我们创建聚合工程时有自己的parent工程，那么我们在自己的父工程定义版本号，根据需要引入对应的包。123456789101112131415&lt;!-- 版本号 --&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;1.5.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;dependencyManagement&gt; 2、编写应用入口类1234567891011121314151617181920package com.fyft.test;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** *&lt;p&gt;Title: TestApplication.java&lt;/p&gt; *&lt;p&gt;Description: TODO&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月10日&lt;/p&gt; *@author shen *@version v1.0 */@SpringBootApplicationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125; &#125; 直接执行此主函数项目就启动了，默认的端口是8080，如果需要改变端口可以在此类实现EmbeddedServletContainerCustomizer 接口，这个接口包含内置Servlet容器的一些配置，例如设置访问端口为800312345678910111213@SpringBootApplicationpublic class TestApplication implements EmbeddedServletContainerCustomizer&#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125; @Override public void customize(ConfigurableEmbeddedServletContainer config) &#123; config.setPort(8003); &#125; &#125; 创建Controller类要让Controller被扫描到，必须放在主入口类 TestApplication 的同级目录或下级目录，这样才能被扫描到，注解才会生效。其他的带注解类都是一样的逻辑， Spring Boot 默认扫描入口启动类所在包之下的目录。 打包部署启动Spring Boot工程直接打成jar包就行了，如果工程是要跑在外部web容器的，也可以打成war包发布，这需要修改一些配置，这里先不做介绍。在eclipse上直接用maven打包就行，输入 clean package 命令，勾上Skip Tests 忽略测试就行。 在dos下cd到jar包目录下执行 java -jar xx.jar 启动工程，出现一个错误 原因是 maven 自身打包生成的目录结构和文件和 Spring Boot 需要的有所不同，需要在pom.xml加上一段配置，使用 spring-boot-maven-plugin 来打包123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 若上面的dos正cd到target目录下，须退出此目录，在打包编译时会删除一次target目录，若不退出将会包无法删除此目录，因为你正打开它。再次执行java -jar 命令启动成功","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zguishen.com/tags/web框架/"}]},{"title":"eclipse neon版本打开某些javascript文件异常问题","slug":"eclipse neon版本打开某些javascript文件异常问题","date":"2017-05-01T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/893196a5.html","link":"","permalink":"https://zguishen.com/posts/893196a5.html","excerpt":"","text":"eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常 java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken 照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"多线程","slug":"多线程","date":"2017-04-30T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/5729df21.html","link":"","permalink":"https://zguishen.com/posts/5729df21.html","excerpt":"在编程中，多线程的意思是某个程序同时多个任务，这样的每一个任务则称为一个线程。线程这部分涉及的知识非常多，在实际开发的应用也是非常重要，这里将介绍基本的部分。 概念线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。进程：计算机中已运行程序的实体。进程本身不会运行，是线程的容器。","text":"在编程中，多线程的意思是某个程序同时多个任务，这样的每一个任务则称为一个线程。线程这部分涉及的知识非常多，在实际开发的应用也是非常重要，这里将介绍基本的部分。 概念线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。进程：计算机中已运行程序的实体。进程本身不会运行，是线程的容器。并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。[1] 实现多线程的几种基本方式1、继承Thread类 12345678910111213141516171819202122public class Test02 extends Thread&#123; private String name; public Test02(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test02 test1 = new Test02(\"one--&gt;\"); Test02 test2 = new Test02(\"two--&gt;\"); test1.start(); test2.start(); &#125;&#125; 2、实现Runnable接口 12345678910111213141516171819202122232425public class Test01 implements Runnable&#123; private String name; public Test01(String name)&#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\"---&gt;\"+i); &#125; &#125; public static void main(String[] args) &#123; Test01 test1 = new Test01(\"one\"); Test01 test2 = new Test01(\"two\"); Thread thread1 = new Thread(test1);//使用thread类执行start方法 Thread thread2 = new Thread(test2); thread1.start(); thread2.start(); &#125;&#125; 3、使用Callable和Future接口创建线程 123456789101112131415161718192021public class Test03 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i); &#125; return null; &#125; public static void main(String[] args) &#123; Test03 t1 = new Test03(); Test03 t2 = new Test03(); FutureTask&lt;Integer&gt; task1 = new FutureTask&lt;&gt;(t1); FutureTask&lt;Integer&gt; task2 = new FutureTask&lt;&gt;(t2); new Thread(task1, \"新建线程1\").start(); new Thread(task2, \"新建线程2\").start(); &#125;&#125; 线程状态使用getState()方法可获取当前线程的状态(枚举类型)，各种状态如下： New（新生)当new一个新的线程时，线程还没开始运行时，状态是new123456public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(); System.out.println(thread.getState()); &#125;&#125; 输出NEW Runnable（可运行）线程调用start执行时12345678910111213public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125;); thread.start(); System.out.println(thread.getState()); &#125;&#125; 输出RUNNABLEi is 0i is 1…i is 99 Blocked（被阻塞）当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。1234567891011121314151617181920212223242526272829public class Test &#123; final Object lock = new Object(); class Example implements Runnable&#123; private String name; public Example(String name) &#123; this.name = name; &#125; @Override public void run() &#123; //同步代码块 synchronized (lock) &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\": i is \"+i); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Example example1 = new Test().new Example(\"test1\"); Example example2 = new Test().new Example(\"test2\"); Thread thread1 = new Thread(example1); Thread thread2 = new Thread(example2); thread1.start(); thread2.start(); System.out.println(thread1.getState()); System.out.println(thread2.getState()); &#125;&#125; 输出RUNNABLEtest1: i is 0test2: i is 0test1: i is 1BLOCKEDtest1: i is 2… Waiting（等待）等待状态，释放自身的锁进入Waiting状态并加入线程等待队列12345678910111213141516171819202122public class Test &#123; public synchronized void testMethod()&#123; try &#123; this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; new Test().testMethod(); &#125; &#125;); thread1.start(); Thread.sleep(10);//主线程休眠，转而去执行子进程 System.out.println(thread1.getState()); &#125;&#125; 输出WAITINGwaiting closed并不会输出 Timed waiting（计时等待）在this.wait();加上等待时间就会进入计时等待状态，例如this.wait(3000);等待三秒输出内容TIMED_WAITINGwaiting closed. Terminated（被终止）run方法执行结束线程终止 123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"run success\"); &#125; &#125;); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); &#125;&#125; 线程管理 sleep方法static void sleep(long millis)让当前正在运行的线程休眠一段时间sleep是一个静态方法，不要用实例化的线程对象调用，其作用的是当前正在运行的线程。Thread.sleep(2000);表示让当前线程休眠2秒，这里的2秒并不是准确的时间段，因为线程是由系统控制，实际时间可能大于2秒。 yield方法static void yield()暂停当前正在执行的线程，重新进入就绪状态，这也是和sleep方法的区别的地方。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。 join方法合并线程。等待终止指定的线程，让主线程等待子线程结束之后再执行 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"one--\"+i); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"two--\"+i); &#125; &#125; &#125;); thread2.start(); &#125;&#125; thread1在thread2中启动，为thread2子线程，调用join，等待thread1执行结束再执行thread2，相当于把两线程合并了。void join(long millis)join重载方法带参数，在指定时间段子线程未执行完将重新进入就绪状态，等待cpu调度。 notify和notifyAll方法notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程。1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public synchronized void testMethod()&#123; try &#123; System.out.println(\"thread start.\"); this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void notifyMethod()&#123; this.notifyAll(); &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; test.testMethod(); &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; test.notifyMethod(); System.out.println(\"唤醒线程.....\"); &#125; &#125;); thread1.start(); Thread.sleep(1000); System.out.println(thread1.getState()); thread2.start(); &#125;&#125; 输出thread start.WAITING唤醒线程.....waiting closed. interrupted和isInterruptedInterrupted方法是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted方法会清除该线程的中断状态。另一方面，isInterrupted方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。 setPriority和getPriorityvoid setPriority(int newPriority)设置线程的优先级。优先级必须在Thread.MIN_PRIORITY 与Thread.MAX_PRIORITY之间。一般使用Thread.NORM_PRIORITY 优先级。final int getPriority()获取线程的优先级 结束线程Tread中有stop方法，但改方法已经过时，不推荐使用。要结束线程，可设置标志来实现。 12345678910111213141516171819202122public class Test &#123; class TestTread implements Runnable&#123; private boolean flag; private void stopThread() &#123; this.flag=true; &#125; @Override public void run() &#123; for(int i=0; i&lt;1000 &amp;&amp; !flag; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestTread test = new Test().new TestTread(); Thread thread1 = new Thread(test); thread1.start(); Thread.sleep(3);//休眠延时 test.stopThread(); &#125;&#125; 输出一段i的值之后当执行stopThread方法线程就结束了。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"Linux下安装Nginx并配置一个图片服务器","slug":"Linux下安装Nginx并配置一个图片服务器","date":"2017-04-20T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/18279bff.html","link":"","permalink":"https://zguishen.com/posts/18279bff.html","excerpt":"首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos6的虚拟机 1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz； 2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹；","text":"首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos6的虚拟机 1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz； 2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹； 3、在解压的文件夹（nginx-1.10.3）下执行./configure --prefix=/home/nginx 命令。意思即配置安装环境，将会把Nginx安装到/home/nginx下； 若没有gcc，先安装yum -y install gcc gcc-c++ autoconf automake make 若出现缺少依赖包则先安装依赖包，以下纯净centos mini版碰到的两个依赖包问题出现上面这个执行 yum -y install pcre-devel 安装依赖， 出现这个yum install -y zlib-devel 安装依赖， 若还有其他依赖问题，根据缺少的文件提示安装相应的东西； 4、编译：在解压的文件夹下先后执行make 和 make install 命令 5、Nginx默认使用端口是80，这里直接先把Nginx端口改为8088，vi /home/nginx/conf/nginx.conf，修改server的端口，并配置一个图片服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8088; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; expires 24h; root /home/images/;#指定图片存放路径 access_log /home/nginx/logs/images.log;#图片 日志路径 proxy_store on; proxy_store_access user:rw group:rw all:rw; proxy_temp_path /home/images/;#代理临时路径 proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:8088;#代理访问地址 &#125; &#125; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; server下listen的端口改为8088，并增加一个location配置，用于访问图片文件，这一串配置有#号在前面的注释掉的都可以删掉，免得看起来又长又乱。 6、启动命令： /home/nginx/sbin/nginx -c /home/nginx/conf/nginx.conf。打开防火墙对应端口供访问，8088，当然也可以直接关了防火墙。若修改了nginx.conf配置，则需要重启才生效，命令：/home/nginx/sbin/nginx -s reload 7、访问。输入ifconfig命令查看虚拟机ip，测试： 在/home/images下放张图片，测试访问：","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zguishen.com/tags/Linux/"}]},{"title":"eclipse neon git 提交窗口太小问题","slug":"eclipse neon git 提交窗口太小问题","date":"2017-04-15T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/f93d19fd.html","link":"","permalink":"https://zguishen.com/posts/f93d19fd.html","excerpt":"","text":"eclipse neon 版本更新了git工具EGit版本，默认commit时使用的是一个标签窗口，不是像之前一个新 dialog窗口，像下面这样：不能单独作为新窗口拖出来的，个人用起来也觉得操作真的是不方便，翻了下设置，在Window-Preferences-Team-Git-Committing可以看到第一个选项 Use Staging View … （使用staging代替原来dialog的commit视图），把这个打钩去掉提交界面就回到前版本的样子","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"反射","slug":"反射","date":"2017-04-03T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/7af799fd.html","link":"","permalink":"https://zguishen.com/posts/7af799fd.html","excerpt":"相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。 使用反射，可以做到： 在运行中分析类的能力。 在运行中查看对象，例如，编写一个toString方法供所有类使用。 实现数组的操作代码。 利用Method对象，这个对象很像C++中的函数指针。 反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）","text":"相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。 使用反射，可以做到： 在运行中分析类的能力。 在运行中查看对象，例如，编写一个toString方法供所有类使用。 实现数组的操作代码。 利用Method对象，这个对象很像C++中的函数指针。 反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）一、反射获取类 新建一个Student类123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private int age; private String name; //无参构造 public Student() &#123; &#125; //有参构造 public Student(int age, String name)&#123; this.age = age; this.name = name; System.out.println(\"My name is \"+name+\",I'm \"+age+\" years old.\"); &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void learning() &#123; System.out.println(\"learning...\"); &#125; &#125; 测试类1234567891011121314151617181920212223public class ReflexTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Student student = new Student(20, &quot;shen&quot;);//一般创建对象 Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);//通过Class获取指定类的完整结构 System.out.println(&quot;getName---&gt;&quot;+stu.getName()); Student s = null; Student s1 = null; try &#123; s = (Student)stu.newInstance();//默认构造的是无参构造，若存在有参构造，这里将报错 Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 s1 = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 Constructor[] constructors = stu.getConstructors();//所有构造 s1 = (Student)constructors[0].newInstance();//第一个构造(无参那个) &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出：Class类forName方法通过完整包路径类型来实例化Class对象，再通过Class对象获取Student类实例；再使用newInstance()创建对象，这里要注意Student的构造方法，默认使用的试试无参构造，可使用Constructor类操作构造方法。 二、获取类的基本结构 1、使用反射操作对象属性12345678910111213141516171819202122232425262728public class Test01 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Student s = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 //Field[] fields = stu.getFields();//获取public的属性 Field[] fields = stu.getDeclaredFields();//获取所有属性 for(Field field : fields)&#123; System.out.println(&quot;属性--&gt;&quot;+field); &#125; Field fieldName = stu.getDeclaredField(&quot;name&quot;);//获取私有变量name fieldName.setAccessible(true); System.out.println(fieldName.getName());//私有属性名称 System.out.println(fieldName.get(s));//私有属性值 fieldName.set(s, &quot;a-shen&quot;); System.out.println(fieldName.get(s));//改变私有属性值 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出 其中对于fieldName.setAccessible(true);使用java反射获取类的属性值时，如果该属性被声明为private 的，需要将setAccessible设置为true. 默认的值为false 2、使用反射访问成员函数通过反射调用方法，使用invoke方法 12345678910111213141516171819202122232425262728public class Test02 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Constructor[] constructors = stu.getConstructors(); Student s = (Student)constructors[0].newInstance();//无参构造对象 //Method[] methods = stu.getMethods();//获取类所有方法，包括继承自父类和实现接口的方法 Method[] methods = stu.getDeclaredMethods();//获取类本身各类方法和实现接口的方法及重写的方法，不包括继承的方法 for(Method method : methods)&#123; System.out.println(&quot;成员函数---&gt;&quot;+method); &#125; Method m1 = s.getClass().getMethod(&quot;setName&quot;, String.class); m1.invoke(s, &quot;ashen&quot;);//设置name值为&quot;ashen&quot; Method m2 = s.getClass().getMethod(&quot;getName&quot;); String name = (String) m2.invoke(s); System.out.println(&quot;getName---&gt;&quot;+name);//输出name值 &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"Mysql存储过程","slug":"Mysql存储过程","date":"2017-02-25T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/f54db9bb.html","link":"","permalink":"https://zguishen.com/posts/f54db9bb.html","excerpt":"当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。 存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板","text":"当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。 存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板123456789101112131415161718192021222324DROP PROCEDURE IF EXISTS TEST_FUNCTION;/*定义存储过程名称，设置入参，指定类型和大小*/CREATE PROCEDURE TEST_FUNCTION(in DATA_A INT(20),in DATA_B INT(20),in B_TYPE varchar(20))BEGIN /*DECLARE 关键字用于定义变量*/ DECLARE SUM int default 0; DECLARE t_error INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET t_error=1;/*异常标志*/ START TRANSACTION;/*启动事务*/ /*字符串的判断，STRCMP用法类似于C++*/ if STRCMP(B_TYPE,'SUM')=0 then begin SELECT DATA_A+DATA_B INTO SUM;/*INTO 把值放到变量中*/ SELECT SUM; end;/*一个begin对应一个end*/ end if;/*一个if对应一个end if*/ IF t_error = 1 THEN ROLLBACK;/*异常回滚*/ ELSE COMMIT;/*正常提交*/ END IF;END; 创建生成的样子 DEFINER的信息是’用户名‘@’host’ 输入参数值测试 调用存储使用call命令","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zguishen.com/tags/数据库/"}]},{"title":"内部类相关——定义、匿名内部类、回调实现及静态内部类","slug":"内部类相关——定义、匿名内部类、回调实现及静态内部类","date":"2017-02-22T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/d4920cf6.html","link":"","permalink":"https://zguishen.com/posts/d4920cf6.html","excerpt":"内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。 1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。","text":"内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。 1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。123456789101112131415161718192021222324public class Cat extends Walk&#123; //private私有类，继承Walk和Eat private class LittleCat extends Eat &#123; public void doSomething() &#123; System.out.println(\"Walking....Eating....\"); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//创建内部类对象方式，通过先创建所在外围类对象再创建内部类对象 lCat.doSomething(); &#125; public void event(final String name) &#123; class EatFish&#123; public void eat() &#123; //name = \"Tom\";//在这里修改会报错，name 必须为final类型，保证数据一致 System.out.println(name); &#125; &#125; EatFish test = new EatFish(); test.eat(); &#125;&#125; 两个父类：12public class Walk &#123;&#125; 12public class Eat &#123;&#125; 2、匿名内部类从名称可以知道匿名就是没有类名的类，匿名内部类用于快速调用接口或抽象类等等中的方法，不需要多写一个实现类来实现调用。 抽象类123public abstract class Dog &#123; abstract void eat();&#125; 接口123public interface Animal &#123; void eat();&#125; 测试类123456789101112131415161718192021222324252627public class AnonymousDemo &#123; public static void main(String[] args) &#123; /** * 通过创建的一个接口或抽象类分引用，快速便捷重写需要实现的方法，不需要先写一个实现类再实例化以调用方法 */ //实现接口方式 Animal dog = new Animal() &#123; @Override public void eat() &#123; System.out.println(&quot;like bone.&quot;); &#125; &#125;; dog.eat();//向上转型的实例，直接调用重写的eat方法 //继承抽象类的方式 Dog littleDog = new Dog() &#123; @Override void eat() &#123; System.out.println(&quot;I like bone.&quot;); &#125; &#125;; littleDog.eat(); &#125;&#125; 此外，Java的回调函数式可以通过匿名内部类来实现，比如以下例子 (1)封装的类和提供的接口封装给别人调用的类1234567891011121314151617181920212223242526public class Person &#123; private EatFood eatFood; /** * 普通方式，构造传递引用 */ public Person(EatFood eatSomething)&#123; this.eatFood = eatSomething;//构造时传入引用 &#125; /** * 普通方式，成员函数传递引用 */ public Person()&#123; &#125; public void setCallBack(EatFood eatSomething) &#123; this.eatFood = eatSomething;//用成员函数传入引用 &#125; //需要调用的方法 public void eatFood() &#123; eatFood.eat(); &#125;&#125; 调用类需要的接口定义123public interface EatFood &#123; void eat();&#125; (2)实际调用一般做法都会写一个类实现接口 1234567public class EatRice implements EatFood &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125;&#125; 然后是实际使用的类123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; //普通方式，构造传递引用 Person personOne = new Person(new EatRice());//EatRice实现类方式。多写一个方法传入也可 personOne.eatFood(); //普通方式，成员函数传递引用 Person personOne = new Person(); EatRice eatRice = new EatRice(); personOne.setCallBack(eatRice); personOne.eatFood();&#125; 如果使用匿名内部类就便捷了许多123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; Person personTwo = new Person(new EatFood() &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125; &#125;); personTwo.eatFood(); &#125;&#125; 3、静态内部类创建是不需要依赖于外围类，但也不能使用任何外围类的非static成员变量和方法 1234567891011121314151617181920212223242526272829public class Cat&#123; private String str = &quot;cat&quot;; private static String str_static = &quot;cat&quot;; private class LittleCat&#123; //public static String str_test = &quot;test&quot;;//错误，非静态内部类变量不能为静态 public static final String str_test = &quot;test&quot;;//但加上final就可以 public void doSomething() &#123; str = &quot;little cat&quot;; System.out.println(&quot;Walking....Eating....&quot;); &#125; &#125; static class BigCat&#123; public void doSomething() &#123; //str = &quot;little cat&quot;;//错误，静态内部类反问外围非静态变量和方法 str_static = &quot;big cat&quot;; System.out.println(&quot;I am a big cat.&quot;); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//依赖外围类 lCat.doSomething(); BigCat bigCat = new BigCat();//不依赖外围类 bigCat.doSomething(); &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"无题","slug":"0214广州","date":"2017-02-13T16:00:00.000Z","updated":"2021-03-16T07:44:09.010Z","comments":true,"path":"posts/9b44950b.html","link":"","permalink":"https://zguishen.com/posts/9b44950b.html","excerpt":"","text":"本命年暂且不用去想太多破事，认真过好今年 E时光上的广州","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"鸡年大吉","slug":"除夕","date":"2017-01-26T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/398752aa.html","link":"","permalink":"https://zguishen.com/posts/398752aa.html","excerpt":"","text":"2017除夕辞旧迎新新年快乐","categories":[{"name":"生活","slug":"生活","permalink":"https://zguishen.com/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"给博客换个主题","slug":"给博客换个主题","date":"2016-12-28T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/9b8edcaf.html","link":"","permalink":"https://zguishen.com/posts/9b8edcaf.html","excerpt":"搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。 转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。 加首歌试试 markdown真是好用啊。顺便加上多说评论。 以下测试","text":"搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。 转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。 加首歌试试 markdown真是好用啊。顺便加上多说评论。 以下测试 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"欢迎来到啊深的博客。\"); &#125;&#125; 故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，惟见长江天际流。 16/12/29","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zguishen.com/tags/博客/"}]},{"title":"欢迎来到我的博客","slug":"hello-world","date":"2016-12-19T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/b250e9bb.html","link":"","permalink":"https://zguishen.com/posts/b250e9bb.html","excerpt":"","text":"之前鼓捣服务器的时候买了个域名耍耍，空间到期之后域名一直放着，不久前才想起github上能搭个博客能用自定义域名，而且刚好又不需要备案，就鼓捣了这个博客。顺便把CSDN的博文同步过来试试，CSDN博客地址 http://blog.csdn.net/u012809062 。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"继承、多态、封装、抽象类与接口","slug":"继承、多态、封装、抽象类与接口","date":"2016-09-04T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/1ef809a2.html","link":"","permalink":"https://zguishen.com/posts/1ef809a2.html","excerpt":"作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。一、继承 利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术] 新建一个人物父类","text":"作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。一、继承 利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术] 新建一个人物父类12345678910111213141516public class Person &#123; private int age; private String name; public Person(int age, String name)&#123; this.age = age; this.name = name; &#125; public void info()&#123; System.out.println(age); System.out.println(name); &#125; &#125; Teacher子类继承Person父类，关键字extends表示继承，extends表明正在构造的新类派生于一个已存在的类。已存在的类被称为超类（superclass）、基类（base class）或父类（parent class）；新类被称为子类（subclass）、派生类（derived class）或孩子类（child class）。 1234567891011121314151617181920212223242526public class Teacher extends Person &#123; //默认实现无参构造并可以不写，如果父类存在带参构造，则需要显式实现此构造 public Teacher(int age, String name) &#123; super(22, &quot;shen&quot;); // TODO Auto-generated constructor stub super.info(); &#125; //重写父类方法 @Override public void info()&#123; System.out.println(&quot;rewrite...&quot;); &#125; public static void main(String[] args) &#123; Teacher t = new Teacher(20, &quot;tutu&quot;); t.info();//子类拥有所有父类的成员变量，但private的成员变量没有访问权限 //t.age//private变量不可访问 &#125; &#125;输出结果：22shenrewrite... 二、多态实现多态有三个条件：要有继承、要有重写、父类引用指向子类对象。父类：12345678910public class Animal &#123; public void eat()&#123; System.out.println(&quot;eat food&quot;); &#125; public void walk()&#123; System.out.println(&quot;walk alone&quot;); &#125;&#125; 子类： 123456789101112131415161718192021222324252627282930public class Dog extends Animal &#123; //重写父类方法 @Override public void eat()&#123; System.out.println(&quot;eat bone&quot;); &#125; public void walk(String dog1)&#123; dog1 = &quot;tom&quot;; System.out.println(&quot;walk with &quot; + dog1); &#125; public static void main(String[] args) &#123; Animal dog = new Dog();//向上转型，父类引用指向子类对象 dog.eat(); dog.walk(); //dog.walk(&quot;jane&quot;);//只能调用父类存在的方法 Dog dd = (Dog)dog;//向下转型 dd.walk(); dd.walk(&quot;jane&quot;); &#125;&#125;输出结果：eat bonewalk alonewalk alonewalk with tom 多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。三、封装在面向对象程式设计方法中，封装指一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。通常都使用getter和setter方法来实现，其他类要访问本类的私有成员变量都需要通过getter和setter方法。例实体类：1234567891011121314151617public class Person &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Person t = new Person(); t.setAge(20); t.setName(&quot;shen&quot;); System.out.println(&quot;Age:&quot; + t.getAge() + &quot; name:&quot; + t.getName()); &#125; &#125;输出：Age:20 name:shen 四、抽象与接口1、我们知道，在面向对象世界中，所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。例： 12345678910111213141516public abstract class Animal &#123; private String name; private float weight; public Animal(String name, float weight)&#123; this.name = name; this.weight = weight; &#125; abstract void run();//抽象类不一定有抽象方法，但包含抽象方法的类一定要被声明为抽象类 public void eat()&#123; &#125;&#125; 继承： 12345678910111213141516171819202122public class Cat extends Animal&#123; public Cat(String name, float weight) &#123; super(name, weight); // TODO Auto-generated constructor stub &#125; //覆盖抽象方法 @Override void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;run fast&quot;); &#125; public static void main(String[] args) &#123; //Animal cat = new Animal(&quot;tom&quot;, 20f);//错误,抽象类不能实例化 Cat cat = new Cat(&quot;tom&quot;, 20f); cat.run(); &#125; &#125; 另注：如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。2、接口接口是抽象方法的集合。接口并不是类，一个类通过继承接口的方式，从而来继承接口的抽象方法。实现接口必须覆盖全部抽象方法，跟抽象类相似。但是java中不能通过extends实现多继承，可以通过实现多个接口来达到多继承的目的。1234public interface Person &#123; public void eat(); public void say();&#125; 实现：123456789101112public class Student implements Person &#123; @Override public void eat() &#123; // TODO Auto-generated method stub &#125; @Override public void say() &#123; // TODO Auto-generated method stub &#125;&#125; 注：接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。接口中的方法都是公有的。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"集合","slug":"集合","date":"2016-08-12T16:00:00.000Z","updated":"2021-03-16T07:44:09.018Z","comments":true,"path":"posts/d366874c.html","link":"","permalink":"https://zguishen.com/posts/d366874c.html","excerpt":"一、概述 集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。 集合框架的接口和实现类：","text":"一、概述 集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。 集合框架的接口和实现类： 二、Iterator接口Iterator接口与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。[引]Iterator接口定义了四个方法–boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。–Object next()：返回集合里下一个元素。–void remove() ：删除集合里上一次next方法返回的元素–void forEachRemaining(Consumer action)：这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。 123456789101112131415161718192021222324252627282930313233/** * @author shen * @desc Iterator接口 * @date 2016年8月23日 */public class IteratorTest &#123; public static void main(String[] args) &#123; //Iterator是Collection父接口，可如此创建集合 Collection&lt;Object&gt; animals = new HashSet&lt;&gt;(); //添加元素 animals.add(&quot;cat&quot;); animals.add(&quot;dog&quot;); animals.add(&quot;pig&quot;); //使用Lambda表达式遍历集合(java1.8新特性) animals.forEach(obj -&gt; System.out.println(&quot;Lambda迭代输出：&quot; + obj)); //iterator()方法获取迭代器 Iterator&lt;Object&gt; data = animals.iterator(); while(data.hasNext())&#123; Object subData = data.next(); if(&quot;cat&quot;.equals(subData))&#123; data.remove();//移除元素 &#125; System.out.println(&quot;迭代器输出：&quot; + subData); &#125; System.out.println(animals); &#125;&#125; 输出： 三、Collection接口 Collection不提供接口的任何直接实现，一个Collection代表一组Object，但它提供更加具体的子接口如List和Set，而继承自它们的 ArrayList, Vector, HashTable, HashMap等实现类才可被实例化。1、List接口List是一个有序集合（ordered collection）。元素可以添加到容器中某个特定的位置。将对象放置在某个位置上可以采用两种方式：使用整数索引或使用列表迭代器。[引 java核心技术]List接口实现类主要有：ArrayList、Vector、LinkedList。(1)ArrayListArrayList是List接口的可变数组的实现，其操作基本是对数组的操作，ArrayList是线程不安全的。ArrayList包装了许多的方法，包括元素的增加移除、插入移动、转换数组等等： 12345678910111213141516171819202122232425262728293031323334353637/** * @author shen * @desc * @date 2016年8月23日 */public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;1&quot;);//使用list时默认长度置为10 list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); list.add(&quot;5&quot;); System.out.println(&quot;list输出：&quot;+list); list.remove(4);//移除元素 System.out.println(&quot;移除元素之后的list：&quot;+list); Object[] arr = list.toArray();//转换为数组 System.out.println(&quot;数组元素输出：&quot;+arr[0]); List&lt;String&gt; c = new ArrayList&lt;&gt;(4);//预计有4个元素而创建 c.add(&quot;6&quot;); c.add(&quot;7&quot;); c.add(&quot;8&quot;); c.add(&quot;9&quot;); c.add(&quot;10&quot;);//超过5个元素list会增加原来长度一半个元素,目前即长度为6 list.addAll(c);//增加一组数据,数据类型应相同 System.out.println(list); Iterator&lt;String&gt; data = list.iterator();//获取迭代器 System.out.println(&quot;迭代输出：&quot;); data.forEachRemaining(action -&gt; System.out.print(action+&quot; &quot;)); &#125;&#125; 输出：ArrayList的各种操作虽然很方便，但是ArrayList的插入和删除，会导致内部数据大量移位，而扩容则需要新建一个ArrayList将原来的数据复制过去,会影响性能。如果我们已经知道需要的元素个数，我们可以初始化时指定ArrayList的容量，这样可以有效的避免数组多次扩充，从而提高效率。(2)VectorVector类提供了实现可增长数组的功能，随着更多元素加入其中，数组变的更大。在删除一些元素之后，数组变小,而不像ArrayList的扩容方式，基本用法与ArrayList相同。Vector是同步类，是线程安全的。(3)LinkedListLinkedList是list的链表实现，列表中的每个节点都包含了对前一个和后一个元素的引用，除了大部分与ArrayList相同的方法，LinkedList还有一些其特有的方法，并且LinkedList在添加和删除元素时具有比ArrayList更好的性能，但在get数据时更慢。LinkedList适用于没有大规模的随机读取，大量的增加/删除操作。[引] 12345678910111213141516171819public class LinkTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;&gt;(); link.add(&quot;a&quot;); link.add(&quot;b&quot;); link.add(&quot;c&quot;); link.add(&quot;d&quot;); link.add(&quot;e&quot;); System.out.println(&quot;第一个元素：&quot;+link.getFirst()+&quot; 最后一个元素：&quot;+link.getLast()); link.remove(1); System.out.println(link); link.add(3, &quot;zhiding&quot;); System.out.println(link); &#125;&#125; 输出： 2、Set接口由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection，只是行为不同。Set不包含重复的元素。Set的实现类主要有：HashSet，TreeSet，LinkedHashSet(1)HashSet不保证set的迭代顺序，不保证该顺序永恒不变，因此HashSet也没有get方法。此类允许使用null元素，底层是使用HashMap实现的。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;adf&quot;); set.add(&quot;bhf&quot;); set.add(&quot;c32&quot;); set.add(&quot;c32&quot;);//有重复元素，添加不了 set.add(null);//null也只允许只有一个 System.out.println(set); for(String str : set)&#123; System.out.print(str +&quot; &quot;); &#125; System.out.println(); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext())&#123; String data = iterator.next(); System.out.print(data +&quot; &quot;); &#125; &#125;输出：[null, bhf, adf, c32]null bhf adf c32 null bhf adf c32 (2)TreeSetTreeSet元素自然排序，底层是使用TreeMap实现的，自定义要显示Comparable接口。TreeSet可以给集合中的元素进行指定方式的排序，保证元素唯一性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author shen * @desc 测试类，实现Comparable&lt;T&gt;接口 * @date 2016年8月24日 */public class User implements Comparable&lt;User&gt;&#123; private String name; private int age; //构造 public User(String name,int age)&#123; this.name = name; this.age = age; &#125; //实现类 @Override public int compareTo(User user) &#123; if(user == null) throw new NullPointerException(); if(this.age &gt; user.age) return 1; if(this.age &lt; user.age) return -1; return 0; &#125; //重写toString @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125;//测试public static void main(String[] args) &#123; Set&lt;User&gt; set = new TreeSet&lt;User&gt;(); User user1 = new User(&quot;Tom&quot;, 20); User user2 = new User(&quot;Jack&quot;, 21); User user3 = new User(&quot;Dave&quot;, 22); User user4 = new User(&quot;Jane&quot;, 12); set.add(user1); set.add(user1);//重复，添加不了 set.add(user2); set.add(user3); set.add(user4); System.out.println(&quot;按年龄大小输出：&quot;); System.out.println(set); &#125;输出按年龄大小输出：[User [name=Jane, age=12], User [name=Tom, age=20], User [name=Jack, age=21], User [name=Dave, age=22]] (3)LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。[引] 四、Map接口在Collection实现中保存的直接是一个个对象，二在Map实现中保存的是一对对象，以键值对key-value的方式关联着。Map的常用实现类有HashMap，HashTabel和TreeMap。1、HashMapHashMap是基于哈希表的Map接口的非同步实现，其中元素表现无序，特别是它不保证该顺序恒久不变。HashMap会利用对象的hashCode来快速找到key。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; //使用实现类创建，键值指定对象类型 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;shen&quot;); map.put(&quot;age&quot;, &quot;20&quot;); map.put(&quot;age&quot;, &quot;19&quot;);//相同键多次存入数据覆盖 map.put(&quot;weight&quot;, &quot;100&quot;); map.put(null, &quot;空&quot;);//允许空键值 map.put(null, null); System.out.println(map); //对map集合的遍历，可取出具体的键和对应值 for(Entry&lt;String, String&gt; element:map.entrySet())&#123; String key = element.getKey(); String value = element.getValue(); Class&lt;? extends Entry&gt; classData = element.getClass(); System.out.println(key + &quot;---- &quot; + value + &quot;---- &quot; + classData.getName()); &#125; //使用接口创建，不关心具体实现，只有在使用才具体实现 //键值的值一般设为Object，不关心什么类型的数据，当然，获取需要具体数据类型或对象需要转化 Map&lt;String, Object&gt; mapData = null;//new HashMap&lt;&gt;(); mapData = new HashMap&lt;&gt;(); mapData.put(&quot;name&quot;, &quot;Jack&quot;); mapData.put(&quot;age&quot;, 21); mapData.put(&quot;weight&quot;, 110.5); System.out.println(mapData); System.out.println(&quot;获取name值:&quot; + mapData.get(&quot;name&quot;)); Set&lt;String&gt; keys = mapData.keySet(); System.out.println(&quot;获取所有key:&quot; + keys); Collection&lt;Object&gt; values = mapData.values(); System.out.println(&quot;获取所有value:&quot; + values); &#125;输出：&#123;null=null, name=shen, weight=100, age=19&#125;null---- null---- java.util.HashMap$Nodename---- shen---- java.util.HashMap$Nodeweight---- 100---- java.util.HashMap$Nodeage---- 19---- java.util.HashMap$Node&#123;name=Jack, weight=110.5, age=21&#125;获取name值:Jack获取所有key:[name, weight, age]获取所有value:[Jack, 110.5, 21] 2、HashTabelHashTable在很大程度事实上和HashMap的实现差不多，主要区别是HashMap采用异步处理方式，性能更高，而HashTabel采用同步处理方式，性能较低。HashTabel属于线程安全类而HashMap属于线程不安全类。[参考] 3、TreeMapTreeMap是可排序的Map集合按照集合中的key进行排序，key不允许重复。TreeMap是红黑树基于Map接口的实现。关于TreeMap红黑树参考,初次接触不容易理解，多查资料。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"类与对象","slug":"类与对象","date":"2016-07-08T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/3a517f26.html","link":"","permalink":"https://zguishen.com/posts/3a517f26.html","excerpt":"一、Java的对象和类Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。1、类(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。(2)类中的变量。包括局部变量、全局变量和类变量。 局部变量：定义在方法中的变量，作用域为本方法中。 成员变量：定义在类中方法外的变量，作用域为本类。 类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。","text":"一、Java的对象和类Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。1、类(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。(2)类中的变量。包括局部变量、全局变量和类变量。 局部变量：定义在方法中的变量，作用域为本方法中。 成员变量：定义在类中方法外的变量，作用域为本类。 类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。 123456789101112131415161718192021222324252627282930/** * @author shen * @desc test * @date 2016年7月10日 */public class Book &#123; static int num = 0;//类变量 static final String type = &quot;children&quot;;//用final变量只能被初始化一次，之后不能再赋值 String str=&quot;this is a book&quot;;//实例变量 public void borrow()&#123; int i = 0;//局部变量 &#125; public static void rend()&#123; //静态方法，无需创建对象就能使用 System.out.println(&quot;this is a static method.&quot;); &#125; public static void main(String[] args) &#123; rend();//直接调用 System.out.println(&quot;this is a main function.&quot;); &#125; static &#123; //静态代码块，类加载时调用 System.out.println(&quot;this is a static code block.&quot;); &#125;&#125; 结果：(3)构造方法 每个类都有构造方法，如果没有显式定义构造方法，编译器会默认为类创建一个不带参的构造方法(若子类继承有带参构造方法的父类，需要显式调用父类构造方法)。 构造方法名必须与类名相同，一个类中可以有多个构造方法(参数不同)，创建对象时至少一个构造方法。2、对象 对象的创建：声明，声明类的类型和名称；实例化，使用new创建一个对象；初始化，创建对象时会调用构造方法初始化对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @author shen * @desc test * @date 2016年7月10日 */public class User &#123; private String type = &quot;student&quot;; private String name;//私有属性只能在本类获取到 private int age; public int height;//公有属性其他类也能获取到 public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; //Javabean的规范，通过getter和setter对数据进行封装 public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User()&#123; //无参构造方法 &#125; public User(String num)&#123; //带参构造 &#125; public User(String name,int age)&#123; //参数个数不同的构造 this.name = name; this.age = age; &#125; //普通方法 public void borrow(String bookName)&#123; //bookName为方法体中的局部变量 System.out.println(this.name + &quot; borrow a book :&quot; + bookName ); &#125; public static void main(String[] args) &#123; User jack = new User();//默认的无参构造创建对象 jack.age = 20;//私有属性，只能在本类使用这种方式 jack.name = &quot;jack&quot;; //公有属性其他类也能获取到，暴露了数据细节。将属性定义为private并使用getter和setter方法隐藏数据的细节(Java的封装特性) jack.height = 170; jack.borrow(&quot;Java code&quot;); System.out.println(jack.type); User jane = new User(); jane.setAge(19);//Javabean规范，实现对数据细节的隐藏封装 jane.setName(&quot;jane&quot;); jane.setType(&quot;teacher&quot;); jane.borrow(&quot;C prime plus&quot;); System.out.println(jane.type); User tom = new User(&quot;tom&quot;, 21);//使用带参构造创建对象 tom.borrow(&quot;C++ prime plus&quot;); &#125; &#125; 结果： 二、基本规则1、一个源文件中只能有一个public类，可以有多个非public类，并且public类名必须与源文件名称相同2、包与import语句(1)Java包主要是用来给类分类，创建包使用package语句实现。包也有基本的命名规则，根据公司或个人名、项目名、模块名等命名。(2)import语句。import语句就是用来提供一个合理的路径，使得编译器可以找到某个类，有点类似与c的头文件和c++的命名空间。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"字符相关","slug":"字符相关","date":"2016-07-08T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/fb57e9c0.html","link":"","permalink":"https://zguishen.com/posts/fb57e9c0.html","excerpt":"一、字符类型char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。char是类型表示的是字符，不是字符串；char类型变量值只能用单引号来表示，不可使用双引号；即表示单引号内的单个字符。","text":"一、字符类型char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。char是类型表示的是字符，不是字符串；char类型变量值只能用单引号来表示，不可使用双引号；即表示单引号内的单个字符。 12345678910111213141516171819202122232425262728/** * @author shen * @desc char test * @date 2016年7月15日 */public class CharTest &#123; public static void main(String[] args) &#123; //单引号内的单个字符 char test = &apos;C&apos;; System.out.println(test); //数组 char cha[] = &#123;&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;&#125;; System.out.println(cha); //Unicode编码，每一个字符用16位2进制数标识 char ucode = &apos;\\u4F60&apos;;//20320 char hao = &apos;\\u597d&apos;;//22909 System.out.print(ucode); System.out.println(hao); //转换成的对应值 System.out.println( ucode + hao); &#125;&#125;由于其编码方式，编码方式最多有65536种，远不足以使用，以及在数据库存储的一些问题，在一般情况下，char在java中的实际使用比较少，也并不推荐使用。 二、字符串类1、String(1)String类表示字符串，是字符串常量(另:常量池)，其值在创建后不能改变，因此Stirng对象创建后是不可变的，直至到被GC回收。(2)创建String对象 1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; String str1 = &quot;Java&quot;;//直接创建 String str2 = new String();//面向对象基本创建方法,有时浪费内存 str2 = &quot;C++&quot;; String str3 = new String(&quot;C&quot;);//String类提供许多构造创建方法和其他方法,详JDK源码 System.out.println(str1+&quot;--&quot;+str2+&quot;--&quot;+str3); &#125; &#125; (3)常见方法I.获取字符串长度与某个字符 123String str = &quot;Java Code&quot;;str.charAt(0);//获取某个下标对应字符str.length();//字符串长度 II.str.compareTo方法 该方法的作用是比较两个字符串的大小，比较的原理是依次比较每个字符的字符编码。首先比较两个字符串的第一个字符，如果第一个字符串的字符编码大于第二个的字符串的字符编码，则返回大于0的值，如果小于则返回小于0的值，如果相等则比较后续的字符，如果两个字符串中的字符编码完全相同则返回0。 123String data1 = &quot;Javi&quot;;String data2 = &quot;Java&quot;;int value = data1.compareTo(data2); III.截取方法 123String str = &quot;Java Code&quot;;String subStr = str.substring(7);//截取得到从某个下标之后的字符串String sub = str.substring(0, 5);//截取区间之内的字符串 IV.连接方法 12345String st1 = &quot;Java&quot;;String st2 = &quot;Code&quot;;String st = st1.concat(st2);//连接组成一个新的字符串JavaCodeString stt = st1+st2;//更直接的做法JavaCodeString sst = st1+007;//参与连接中有字符串按字符串连接Java007 V.查找方法 123String str = &quot;Java Code&quot;;int i = str.indexOf(&apos;o&apos;);//某个在字符串第一次出现的下标,不存在则返回-1int j = str.indexOf(&apos;o&apos;, 7);//从第几个字符开始查,返回下标，不存在则返回-1 VI.replace方法 该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。12String str = &quot;Java Code&quot;;String s = str.replace(&quot;Java&quot;, &quot;C++&quot;);//把Java代替成C++ VII.split方法 以特定的分隔符分隔字符串，生成一个 数组。 12345String data = &quot;java,c++,c,c#&quot;;String arr[] = data.split(&quot;,&quot;);for(int k = 0;k&lt;arr.length;k++)&#123; System.out.println(arr[k]);&#125; 2、Stringbuffer 同样是字符串类，Stringbuffer 是字符串变量，实现方式与String有所不同，在进行处理字符串时不生成新的对象。在存储和操作字符串操作比String更合适。I.字符串拼接 1234StringBuffer data = new StringBuffer(&quot;The&quot;);//创建对象StringBuffer data1 = data.append(&quot; Great&quot;);//拼接方法String str = &quot; Wall&quot;;data1.append(str).append(&quot;!&quot;); II.deleteCharAt方法 此外，字符串操作相关的方法还有insert插入、reverse反转倒序、setCharAt修改某个下标上的字符、trimToSize将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费。3、Stringbuilder Stringbuilder和StringBuffer基本类似，相关方法也一样 4、String、StringBuffer和Stringbuilder的具体区别[以下复制,来自其他博主总结]String：字符串常量StringBuffer：字符创变量，线程安全StringBuilder：字符创变量，非线程安全 如果要操作少量的数据用String单线程操作字符串缓冲区下操作大量数据StringBuilder多线程操作字符串缓冲区下操作大量数据StringBuffer5、其他[引用]I.字符串比较”==”与equal()方法“==” 判断两个引用的是不是同一个内存地址(同一个物理对象).equals 判断两个字符串的值是否相等.除非你想判断两个string引用是否同一个对象,否则应该总是使用 equals()方法.II.密码及其他问题上char[]优先于String原因 String是不可变对象, 意思是一旦创建,那么整个对象就不可改变. 即使新手觉得String引用变了,实际上只是(指针)引用指向了另一个(新的)对象. 而程序员可以明确地对字符数组进行修改,因此敏感信息(如密码)不容易在其他地方暴露(只要你用完后对char[]置0).","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"Java 简介和开发环境","slug":"Java 简介和开发环境","date":"2016-06-30T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/b8d10806.html","link":"","permalink":"https://zguishen.com/posts/b8d10806.html","excerpt":"一、定义与特点定义：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。[Java疯狂讲义]特点：主要特点是面向对象和可移植等等，广泛应用于web应用程序(JavaEE相关)、嵌入式(安卓相关)，桌面程序、分布式系统等等。","text":"一、定义与特点定义：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。[Java疯狂讲义]特点：主要特点是面向对象和可移植等等，广泛应用于web应用程序(JavaEE相关)、嵌入式(安卓相关)，桌面程序、分布式系统等等。二、开发工具和开发环境JDK：Java开发包或Java开发工具，编写Java程序必须，已包含JRE。JRE：Java运行环境，运行编写完毕的Java程序。JDK的安装(Windows系统,Java8)1、首先到oracle官网下载与计算机系统对应的Java SE的JDK即可。2、安装、配置环境变量配置JAVA_HOME的环境变量：新建JAVA_HOME一个变量，路径为JDK的安装路径，指定到jdk文件夹jdk的版本是1.8，在1.6版本之后的jdk都不必配置classpath环境变量了。3、基本命令win+r运行cmd，输入java命令，可以看到各种选项命令 输入java -version可以看到当前安装的jdk版本信息 javac命令，各种编译选项三、基本数据类型1、Java有八种基本数据类型，包括byte字节类型、int整形、short短整形、long长整形、char字符型、float浮点型(单精度)、double双精度类型、boolean布尔型。2、基本知识一个字节等于8位，一个字节等于256个数，就是-128到127一共256。kB就是kBytesBytes就是“字节”的意思！K就是千的意思，因为计算机是通过二进制来计算，10个1正好是10241111111111（二进制）=1024（十进制）1Bytes（字节）=8bit（比特）一个英文字母或一个阿拉伯数字就是一个字符，占用一个字节一个汉字就是两个字符，占用两个字节。3、数据类型转换byte-&gt;shortchar-&gt;int-&gt;longfloat-&gt;doubleint-&gt;floatlong-&gt;double范围小的转到范围大的范围大的转换到范围小的会失去精度","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zguishen.com/tags/Java基础/"}]},{"title":"spring springmvc mybatis 整合","slug":"spring springmvc mybatis 整合","date":"2016-04-09T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/9b23218f.html","link":"","permalink":"https://zguishen.com/posts/9b23218f.html","excerpt":"最近鼓捣ssm框架的东西，写篇博文记录。环境 apache-tomcat-8.0.33、jdk1.8.0_05 maven Dynamic Web Module 2.51、各个xml配置文件的配置(1)pom.xml 配置清单文件连接池用的阿里巴巴Druid，数据库mysql，指定jdk编译版本1.8","text":"最近鼓捣ssm框架的东西，写篇博文记录。环境 apache-tomcat-8.0.33、jdk1.8.0_05 maven Dynamic Web Module 2.51、各个xml配置文件的配置(1)pom.xml 配置清单文件连接池用的阿里巴巴Druid，数据库mysql，指定jdk编译版本1.8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.shen&lt;/groupId&gt; &lt;artifactId&gt;ssmdemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ssmdemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 添加spring依赖，对应版本号jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加tomcat下servlet-api依赖,对应版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加jtl支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Spring支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加日志支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加连接池druid支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssmdemo&lt;/finalName&gt; &lt;!-- 指定jdk编译器版本 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; (2)web.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance http://www.springmodules.org/schema/cache/springmodules-cache.xsd http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd &quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring配置文件 --&gt; &lt;!-- --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 解决工程编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 添加对springmvc的支持 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; (3)mybatis配置 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.web.open.model&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; (4)springmvc配置 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 使用注解的包，包括子集 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.controller&quot; /&gt; &lt;!-- 开启注解 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传解析器 id 必须为multipartResolver --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10000000&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (5)数据源及整合配置applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 配置数据源 ,连接池用的阿里druid--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://IP+数据库&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;用户名&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;密码&quot;/&gt; --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://121.42.57.186:3306/blog&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;shen200800&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mappers.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;&gt;&lt;/property&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.web.open.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 5. 使用声明式事务 transaction-manager：引用上面定义的事务管理器--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;check*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;serviceOperation&quot; expression=&quot;execution(* cn.web.open.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceOperation&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.service&quot; /&gt;&lt;/beans&gt; 2、工程结构(1)分层结构 (2)实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.web.open.model;import java.util.Date;public class User &#123; private String userCode; private String userName; private String userPwd; private String email; private String address; private Date userBorn; public String getUserCode() &#123; return userCode; &#125; public void setUserCode(String userCode) &#123; this.userCode = userCode; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPwd() &#123; return userPwd; &#125; public void setUserPwd(String userPwd) &#123; this.userPwd = userPwd; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getUserBorn() &#123; return userBorn; &#125; public void setUserBorn(Date userBorn) &#123; this.userBorn = userBorn; &#125; &#125; dao接口 123456package cn.web.open.dao;import cn.web.open.model.User;public interface UserDao &#123; User findById(String code,String pwd);&#125; service接口 1234567package cn.web.open.service;import cn.web.open.model.User;public interface UserService &#123; User findById(String code,String pwd);&#125; service实现类,@Resource注入dao 12345678910111213141516171819package cn.web.open.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import cn.web.open.dao.UserDao;import cn.web.open.model.User;import cn.web.open.service.UserService;@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123; @Resource private UserDao userDao; public User findById(String code,String pwd) &#123; User user = userDao.findById(code,pwd); return user; &#125;&#125; 控制器controller 12345678910111213141516171819202122232425262728293031323334package cn.web.open.controller;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import cn.web.open.model.User;import cn.web.open.service.UserService;@Controller//@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/login&quot;) public String login(HttpServletRequest request, Model model) &#123; String code = request.getParameter(&quot;usercode&quot;); String pwd = request.getParameter(&quot;password&quot;); User user_login = userService.findById(code,pwd); System.out.println(&quot;---&gt;&quot;+user_login); if (null == user_login) &#123; System.out.println(&quot;Error login!&quot;); return &quot;redirect:index.jsp?oper=error&quot;; &#125; else &#123; model.addAttribute(&quot;user&quot;, user_login); return &quot;pages/success&quot;; &#125; &#125;&#125; sql语句文件mappers/userMapper.xml 1234567891011121314151617181920&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.web.open.dao.UserDao&quot;&gt; &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt; &lt;result column=&quot;USER_CODE&quot; property=&quot;userCode&quot; /&gt; &lt;result column=&quot;USER_NAME&quot; property=&quot;userName&quot; /&gt; &lt;result column=&quot;USER_PWD&quot; property=&quot;userPwd&quot; /&gt; &lt;/resultMap&gt; &lt;!-- 查询条件:账号密码用户类型. 0第一个参数,1第二个参数,对应dao接口参数 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;String&quot; resultMap=&quot;UserResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD FROM BLOG_USER WHERE USER_CODE=#&#123;0&#125; AND USER_PWD=#&#123;1&#125; AND USER_TYPE=2 &lt;/select&gt; &lt;!-- &lt;select id=&quot;getAllUsers&quot; resultMap=&quot;userResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD,CREATE_DATE FROM BLOG_USER &lt;/select&gt; --&gt;&lt;/mapper&gt; (3)前台的一些测试页面WEB_INF下文件不能通过URL直接访问,登录页面网上拿了别人做了一个页面，挺有趣的，访问工程地址,端口你自己配的,输入管理员类型的账号测试刚开始对于各种注解的使用不甚了解鼓捣了许久,用maven管理项目构建时也碰到许多小问题，着实查了许多资料,下过别人的demo参考，总算是把ssm这一套搭起来了，如果发现有问题，请留言指教。demo下载http://download.csdn.net/detail/u012809062/9486330","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zguishen.com/tags/Spring/"}]},{"title":"MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库","slug":"MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库","date":"2015-12-11T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/b119ba3e.html","link":"","permalink":"https://zguishen.com/posts/b119ba3e.html","excerpt":"一、安装MySQL1.本人用的版本是mysql-5.6.24-winx64解压免装版，链接：http://xiazai.zol.com.cn/detail/4/33431.shtml解压后找到my-default.ini文件，复制改名为my.ini，修改添加以下语句：","text":"一、安装MySQL1.本人用的版本是mysql-5.6.24-winx64解压免装版，链接：http://xiazai.zol.com.cn/detail/4/33431.shtml解压后找到my-default.ini文件，复制改名为my.ini，修改添加以下语句：[client]port=3306default-character-set=utf8 [mysqld]port=3306character_set_server=utf8 #以下路径为你解压到的文件夹basedir = D:\\Program Files\\mysql-5.6.24-winx64datadir = D:\\Program Files\\mysql-5.6.24-winx64\\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES2.配置环境变量：计算机-属性-高级系统设置-高级-环境变量，在Path中添加D:\\Program Files\\mysql-5.6.24-winx64\\bin路径依然根据自己所解压到的路径决定，注意添加时前面用；分号隔开。3.win+r进dos，cd到解压文件目录的bin文件下安装服务：mysqld -install启动服务:net start mysql如果要删除服务，命令为：mysqld -remove安装结束———- 二、创建数据库和表以一个简单例子为例，步骤如下:win+r进dos并cd到解压路径的bin文件下，执行mysql -uroot -p因为初始密码为空，直接回车，如图 show databases; 显示目前所有的数据库create database 库名; 因为之前person已经创建过，所有提示存在创建完我们使用它，use person; 接着创建一个表名student的表,有两个简单的属性, 命令:create table &lt;表名&gt; (&lt;字段名 1&gt; &lt;类型 1&gt; [,..&lt;字段名 n&gt; &lt;类型 n&gt;]); 具体如下: 查看表结构命令: show columns from 表名;插入数据命令:insert into &lt;表名&gt; [( &lt;字段名 1&gt;[,..&lt;字段名 n &gt; ])] values ( 值 1 )[, ( 值 n )]以下随便插入两个select * from 表名; 显示表所有内容 三、在eclipse上通过JDBC连接MySQl数据库1.下载对应MySQL的驱动包 http://dev.mysql.com/downloads/connector/j/解压驱动包，eclipse新建一个java工程MysqlDemo，复制驱动包的.jar文件，在java工程右键paste，接着在.jar包右键Build Path - Configure Build Path,这样驱动就加载进来了 测试程序参考自http://qq163230530.blog.163.com/blog/static/4289250620081186262719/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.*;public class MysqlDemo &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = \"com.mysql.jdbc.Driver\"; //URL指向要访问的数据库名mydata String url = \"jdbc:mysql://localhost:3306/person\"; //MySQL配置时的用户名 String user = \"root\"; //MySQL配置时的密码 String password = \"\"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println(\"Succeeded connecting to the Database!\"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = \"select * from student\"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println(\"-----------------\"); System.out.println(\"执行结果如下所示:\"); System.out.println(\"-----------------\"); System.out.println(\" 学号\" + \"\\t\" + \" 姓名\"); System.out.println(\"-----------------\"); String name = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 name = rs.getString(\"name\"); //获取stuid这列数据 id = rs.getString(\"id\"); //首先使用ISO-8859-1字符集将name解码为字节序列并将结果存储新的字节数组中。 //然后使用GB2312字符集解码指定的字节数组。 name = new String(name.getBytes(\"ISO-8859-1\"),\"gb2312\"); //输出结果 System.out.println(id + \"\\t\" + name); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println(\"Sorry,can`t find the Driver!\"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println(\"数据库数据成功获取！！\"); &#125; &#125;&#125; run结果 印象流程大概这样，水平有限，记录。","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zguishen.com/tags/数据库/"}]},{"title":"avr单片机三种时钟模式","slug":"avr单片机三种时钟模式","date":"2015-05-03T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/c8d05ed8.html","link":"","permalink":"https://zguishen.com/posts/c8d05ed8.html","excerpt":"","text":"AVR单片机时钟有三种模式：1、内部时钟源，可分为内部晶振和外部晶振，用的是单片机内部的振荡电路。内部晶振可以设置1M、2M、4M、8MHz晶振频率，外部可支持到16MHz（MEGA16或者MEGA16A）MEGA16L可支持最高8MHz的外部晶振（通过熔丝设置）。2、外部时钟源，靠外部振荡电路提供时钟，可以用外部同步时钟信号（如用其他单片机提供时钟）或者外部振荡器（如有源晶振）将此信号接到单片机XTAL1端口，熔丝设置为外部时钟即可（不是外部晶振）。3、设置晶振熔丝错误会导致芯片锁死，如果设置为外部晶振，直接加晶振即可解除，设置为外部时钟源，那只好提供外部时钟才能解除（有源晶振）。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]},{"title":"opencv简单的彩色图像灰度化和二值化（学习笔记）","slug":"opencv简单的彩色图像灰度化和二值化（学习笔记）","date":"2015-05-03T16:00:00.000Z","updated":"2021-03-16T07:44:09.014Z","comments":true,"path":"posts/af56e9b3.html","link":"","permalink":"https://zguishen.com/posts/af56e9b3.html","excerpt":"图像的灰度化即是将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255255255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。 图像的二值化是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。要对RGB彩色图像进行二值化一般首先要对图像进行灰度化处理。","text":"图像的灰度化即是将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255255255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。 图像的二值化是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。要对RGB彩色图像进行二值化一般首先要对图像进行灰度化处理。例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #include \"cv.h\" #include \"highgui.h\" #include &lt;cvaux.h&gt; int main(int argc, char *argv[]) &#123; IplImage* img; IplImage* img0; IplImage* img1; img = cvLoadImage(\"test.jpg\");//默认初始图像放在工程文件下 //IplImage* img1 = img; if (NULL == img) return 0;//灰度化操作 img0 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCvtColor(img,img0,CV_BGR2GRAY);//图像数据复制 img1 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCopy(img0, img1, NULL);//数据复制，若直接赋值相当指针指向同一地址会对原本img0操作//二值化操作 int height = img1-&gt;height; int width = img1-&gt;width; int step = img1-&gt;widthStep; int channels = img1-&gt;nChannels; uchar *data = (uchar*)img1-&gt;imageData; for(int i=0;i != height; ++ i) &#123; for(int j=0;j != width; ++ j) &#123; for(int k=0;k != channels; ++ k) &#123; if(data[i*step+j*channels+k]&lt;128) data[i*step+j*channels+k]=0;//255-data[i*step+j*channels+k]; else data[i*step+j*channels+k]=255;//255-data[i*step+j*channels+k]; &#125; &#125; &#125;//创建窗口、显示图像、销毁图像、释放图像 cvNamedWindow( \"test1\", 0 ); cvShowImage(\"test1\", img0); cvNamedWindow( \"test\", 0 ); cvShowImage(\"test\", img1); cvWaitKey(0); cvDestroyWindow( \"test1\" ); cvDestroyWindow( \"test\" ); cvReleaseImage( &amp;img0 ); cvReleaseImage( &amp;img1 ); return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://zguishen.com/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zguishen.com/tags/其他/"}]}]}